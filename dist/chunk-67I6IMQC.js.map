{"version":3,"sources":["../src/tools/is-client.ts","../src/tools/is-dev.ts","../src/tools/parse-collection.ts","../src/tools/query-processor.ts","../src/tools/random.ts","../src/tools/session-tracker.ts","../src/tools/logger.ts","../src/bindings/index.ts","../src/bindings/transactions/beginTransaction.ts","../src/bindings/transactions/commitTransaction.ts","../src/bindings/transactions/rollbackTransaction.ts","../src/bindings/count.ts","../src/bindings/create.ts","../src/bindings/find.ts","../src/bindings/delete.ts","../src/bindings/update.ts","../src/bindings/upsert.ts","../src/bindings/drafts.ts","../src/bindings/migrate.ts"],"names":["data","uuidv4","rawDocs","docs","processedQuery","isRecord","splitIncrementOps","applyPatchWithIncrements"],"mappings":"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","file":"chunk-67I6IMQC.js","sourcesContent":["/**\n * @fileoverview Client Environment Detection\n *\n * This module provides a simple flag for detecting whether the\n * code is running in a browser (client) or server environment.\n *\n * @module utils/is-client\n */\n\n/**\n * Boolean flag indicating if the code is running in a browser.\n * True when the `window` object is defined (browser environment).\n *\n * @example\n * ```typescript\n * if (isClient) {\n *   // Browser-only code\n *   window.localStorage.setItem('key', 'value');\n * }\n * ```\n */\ndeclare const window: unknown;\nexport const isClient = typeof window !== \"undefined\";\n","/**\n * @fileoverview Development Environment Detection\n *\n * This module provides a simple flag for detecting whether the\n * application is running in development mode.\n *\n * @module utils/is-dev\n */\n\n/**\n * Boolean flag indicating if the application is in development mode.\n * True when NODE_ENV is set to \"development\".\n *\n * @example\n * ```typescript\n * if (isDev) {\n *   console.log('Running in development mode');\n * }\n * ```\n */\nexport const isDev = process.env.NODE_ENV === \"development\";\n","/**\n * @fileoverview Collection Name Parsing\n *\n * This module provides utilities for parsing and prefixing collection names.\n * Collection prefixing enables multiple Payload instances to share a single\n * Convex deployment without naming conflicts.\n *\n * @module utils/parse-collection\n */\n\n/**\n * Props for the parseCollection function.\n */\nexport type ParseCollectionProps = {\n  /** The prefix to prepend to the collection name */\n  prefix: string;\n  /** The base collection name */\n  collection: string;\n};\n\n/**\n * Parses a collection name by prepending the configured prefix.\n *\n * This function creates a namespaced collection name by combining\n * the prefix and collection name with an underscore separator.\n * Hyphens are converted to underscores to comply with Convex identifier rules.\n *\n * **Idempotent**: If the collection is already prefixed, it returns the collection as-is.\n *\n * @param {ParseCollectionProps} props - The parsing parameters\n * @returns {string} The prefixed collection name with Convex-safe characters\n *\n * @example\n * ```typescript\n * const collectionId = parseCollection({\n *   prefix: 'my_app',\n *   collection: 'users',\n * });\n * // Returns: \"my_app_users\"\n *\n * const collectionId2 = parseCollection({\n *   prefix: 'my_app',\n *   collection: 'payload-preferences',\n * });\n * // Returns: \"my_app_payload_preferences\"\n *\n * // Idempotent - already prefixed collections are returned as-is\n * const collectionId3 = parseCollection({\n *   prefix: 'my_app',\n *   collection: 'my_app_users',\n * });\n * // Returns: \"my_app_users\" (not \"my_app_my_app_users\")\n * ```\n */\nexport function parseCollection(props: ParseCollectionProps) {\n  const { prefix, collection } = props;\n\n  // Check if collection is already prefixed\n  if (collection.startsWith(`${prefix}_`)) {\n    return collection;\n  }\n\n  // Replace hyphens with underscores to comply with Convex identifier rules\n  // Convex identifiers can only contain alphanumeric characters and underscores\n  const sanitizedCollection = collection.replace(/-/g, \"_\");\n  return `${prefix}_${sanitizedCollection}`;\n}\n","/**\n * @fileoverview QueryProcessor for Payload-Convex Data Transformation\n *\n * This module provides a centralized QueryProcessor that handles bidirectional\n * data transformation and query processing between Payload CMS and Convex.\n * It integrates compileToConvex, compileToPayload, parsePayloadWhere, and\n * data compilation into a unified, chainable API.\n *\n * ## Architecture\n *\n * The QueryProcessor operates in two modes:\n * - **Adapter-side (convex: false)**: Runs on the client/adapter side before\n *   sending to Convex. Prepares data and where clauses for Convex operations.\n * - **Convex-side (convex: true)**: Runs inside Convex query/mutation handlers.\n *   Provides chainable query building with filters and transformations.\n *\n * ## Chainable API (Convex-side)\n * ```typescript\n * const processor = service.tools.queryProcessor({\n *   ctx, service, collection, wherePlan, index, convex: true\n * });\n * const results = await processor.query().postFilter().toPayload();\n * ```\n *\n * @module tools/query-processor\n */\n\nimport type {\n  Where,\n  WhereField,\n  Operator,\n  SelectType,\n  JoinQuery,\n} from \"payload\";\nimport type {\n  GenericQueryCtx,\n  GenericMutationCtx,\n  GenericDataModel,\n  PaginationOptions,\n  FilterBuilder,\n  ExpressionOrValue,\n  GenericTableInfo,\n} from \"convex/server\";\n\nimport type { AdapterService } from \"../adapter/service\";\nimport type { AdapaterQueryIndex } from \"../convex/queries\";\nimport { parseCollection } from \"./parse-collection\";\n\n// ============================================================================\n// Where Filter System (migrated from where.ts)\n// ============================================================================\n\n/**\n * Represents a single field comparison in a where filter.\n */\nexport type WhereComparison = {\n  /** The field name to compare */\n  field: string;\n  /** The comparison operator */\n  operator: Operator;\n  /** The value to compare against */\n  value: unknown;\n};\n\n/**\n * Represents a node in the where filter tree.\n * Can be a logical operator (and/or/not) or a field comparison.\n */\nexport type WhereNode =\n  | { type: \"and\"; nodes: WhereNode[] }\n  | { type: \"or\"; nodes: WhereNode[] }\n  | { type: \"not\"; node: WhereNode }\n  | { type: \"comparison\"; comparison: WhereComparison };\n\n/**\n * The parsed where filter type.\n * Null indicates no filter (match all documents).\n */\nexport type ParsedWhereFilter = WhereNode | null;\n\n/**\n * Filter execution strategy.\n * - \"db\": All filters can run in Convex DB (fast, indexed)\n * - \"post\": All filters need post-processing (slow, in-memory)\n * - \"hybrid\": Mix of DB and post-processing\n */\nexport type FilterStrategy = \"db\" | \"post\" | \"hybrid\";\n\n/**\n * Enhanced parsed where filter with hybrid filtering support.\n * Splits filters into DB-compatible and post-processing phases.\n */\nexport type EnhancedParsedWhereFilter = {\n  /** The execution strategy for this filter */\n  strategy: FilterStrategy;\n  /** Filters that can run in Convex DB (null if none) */\n  dbFilter: ParsedWhereFilter;\n  /** Filters that need post-processing (null if none) */\n  postFilter: ParsedWhereFilter;\n};\n\n/**\n * Classifies a comparison to determine if it can use DB filtering.\n * @internal\n */\nfunction classifyComparison(comparison: WhereComparison): boolean {\n  // Nested field paths require post-filtering\n  if (comparison.field.includes(\".\")) {\n    return false;\n  }\n\n  // Unsupported operators require post-filtering\n  const unsupportedOps = [\"contains\", \"like\", \"near\"];\n  if (unsupportedOps.includes(comparison.operator)) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Classifies a where node to determine if it can use DB filtering.\n * @internal\n */\nfunction classifyWhereNode(node: WhereNode): boolean {\n  switch (node.type) {\n    case \"comparison\":\n      return classifyComparison(node.comparison);\n\n    case \"and\":\n    case \"or\":\n      // All children must be DB-compatible\n      return node.nodes.every(classifyWhereNode);\n\n    case \"not\":\n      return classifyWhereNode(node.node);\n  }\n}\n\n/**\n * Splits a where node into DB and post-processing filters.\n * @internal\n */\nfunction splitWhereNode(node: WhereNode): {\n  dbFilter: WhereNode | null;\n  postFilter: WhereNode | null;\n} {\n  // If entire node can use DB, use it\n  if (classifyWhereNode(node)) {\n    return { dbFilter: node, postFilter: null };\n  }\n\n  // If it's a comparison that can't use DB, post-process only\n  if (node.type === \"comparison\") {\n    return { dbFilter: null, postFilter: node };\n  }\n\n  // For NOT, if complex, post-process entire thing\n  if (node.type === \"not\") {\n    return { dbFilter: null, postFilter: node };\n  }\n\n  // For AND nodes, we CAN split - DB filters narrow results, post-filter refines\n  // This is safe because AND requires ALL conditions to match\n  if (node.type === \"and\") {\n    const dbNodes: WhereNode[] = [];\n    const postNodes: WhereNode[] = [];\n\n    for (const child of node.nodes) {\n      if (classifyWhereNode(child)) {\n        dbNodes.push(child);\n      } else {\n        postNodes.push(child);\n      }\n    }\n\n    return {\n      dbFilter:\n        dbNodes.length > 0\n          ? dbNodes.length === 1\n            ? dbNodes[0]\n            : { type: \"and\", nodes: dbNodes }\n          : null,\n      postFilter:\n        postNodes.length > 0\n          ? postNodes.length === 1\n            ? postNodes[0]\n            : { type: \"and\", nodes: postNodes }\n          : null,\n    };\n  }\n\n  // For OR nodes, we CANNOT split - would change semantics\n  // OR requires ANY condition to match, so all must be evaluated together\n  // If any child needs post-filtering, entire OR goes to post-filter\n  if (node.type === \"or\") {\n    // Check if all children can use DB\n    const allDbCompatible = node.nodes.every(classifyWhereNode);\n    if (allDbCompatible) {\n      return { dbFilter: node, postFilter: null };\n    }\n    // Otherwise, entire OR must be post-processed\n    return { dbFilter: null, postFilter: node };\n  }\n\n  return { dbFilter: null, postFilter: node };\n}\n\n/**\n * Parses a Payload Where object into an enhanced filter with hybrid filtering support.\n *\n * This function runs on the client/adapter side and converts Payload's\n * Where syntax into a pure data structure that can be safely serialized\n * and passed to Convex functions. It automatically splits filters into\n * DB-compatible and post-processing phases for optimal performance.\n *\n * @param {Where} [where] - The Payload where clause to parse\n * @returns {EnhancedParsedWhereFilter} The enhanced filter with strategy\n *\n * @example\n * ```typescript\n * const filter = parsePayloadWhere({\n *   status: { equals: 'published' },\n *   'author.name': { equals: 'john' }, // Nested path - needs post-filtering\n * });\n * // Returns: { strategy: \"hybrid\", dbFilter: {...}, postFilter: {...} }\n * ```\n */\nexport function parsePayloadWhere(where?: Where): EnhancedParsedWhereFilter {\n  if (!where || Object.keys(where).length === 0) {\n    return { strategy: \"db\", dbFilter: null, postFilter: null };\n  }\n\n  const parsedNode = parseWhereObject(where);\n  if (!parsedNode) {\n    return { strategy: \"db\", dbFilter: null, postFilter: null };\n  }\n\n  const { dbFilter, postFilter } = splitWhereNode(parsedNode);\n\n  // Determine strategy\n  let strategy: FilterStrategy;\n  if (dbFilter && !postFilter) {\n    strategy = \"db\";\n  } else if (!dbFilter && postFilter) {\n    strategy = \"post\";\n  } else {\n    strategy = \"hybrid\";\n  }\n\n  return { strategy, dbFilter, postFilter };\n}\n\n/**\n * WherePlan type alias for clarity in bindings.\n * Represents the parsed and optimized where filter ready for Convex operations.\n */\nexport type WherePlan = EnhancedParsedWhereFilter;\n\n/**\n * Props for createWherePlan function.\n */\nexport type CreateWherePlanProps = {\n  /** The Payload where clause (optional - undefined/null returns empty plan) */\n  where?: Where | null;\n};\n\n/**\n * Creates a WherePlan from a Payload Where clause.\n *\n * This is the primary entry point for converting Payload's Where syntax\n * into a WherePlan that can be passed to adapter functions.\n *\n * The WherePlan automatically handles:\n * - Splitting filters into DB-compatible and post-processing phases\n * - Date conversion (ISO strings to timestamps)\n * - Nested field path detection for hybrid filtering\n *\n * @param {CreateWherePlanProps} props - The function parameters\n * @returns {WherePlan} The parsed where plan ready for Convex operations\n *\n * @example\n * ```typescript\n * // In a binding function\n * const wherePlan = createWherePlan({ where: incomingParams.where });\n *\n * const docs = await service.db.query({}).collectionWhereQuery.adapter({\n *   service,\n *   collection: 'posts',\n *   wherePlan,\n *   index: undefined,\n * });\n * ```\n *\n * @example Empty where clause\n * ```typescript\n * const wherePlan = createWherePlan({ where: undefined });\n * // Returns: { strategy: \"db\", dbFilter: null, postFilter: null }\n * ```\n */\nexport function createWherePlan(props: CreateWherePlanProps): WherePlan {\n  const { where } = props;\n  return parsePayloadWhere(where ?? undefined);\n}\n\n/**\n * Creates an empty WherePlan (matches all documents).\n * Use this when you need a valid WherePlan but have no filter conditions.\n *\n * @returns {WherePlan} An empty where plan that matches all documents\n *\n * @example\n * ```typescript\n * const docs = await service.db.query({}).collectionWhereLimitQuery.adapter({\n *   service,\n *   collection: globalCollection,\n *   wherePlan: emptyWherePlan(),\n *   limit: 1,\n * });\n * ```\n */\nexport function emptyWherePlan(): WherePlan {\n  return { strategy: \"db\", dbFilter: null, postFilter: null };\n}\n\n/**\n * Recursively parses a Where object into a WhereNode.\n * @internal\n */\nfunction parseWhereObject(where: Where): WhereNode {\n  const nodes: WhereNode[] = [];\n\n  // Handle AND\n  if (Array.isArray(where.and)) {\n    nodes.push({\n      type: \"and\",\n      nodes: where.and.map(parseWhereObject),\n    });\n  }\n\n  // Handle OR\n  if (Array.isArray(where.or)) {\n    nodes.push({\n      type: \"or\",\n      nodes: where.or.map(parseWhereObject),\n    });\n  }\n\n  // Handle NOT\n  if (\"not\" in where && where.not && typeof where.not === \"object\") {\n    nodes.push({\n      type: \"not\",\n      node: parseWhereObject(where.not as Where),\n    });\n  }\n\n  // Handle field conditions\n  for (const [field, value] of Object.entries(where)) {\n    if (field === \"and\" || field === \"or\" || field === \"not\") continue;\n    if (!value || typeof value !== \"object\") continue;\n\n    const fieldConditions = parseWhereField(field, value as WhereField);\n    nodes.push(...fieldConditions);\n  }\n\n  // If no valid conditions found, treat as \"match all\"\n  if (nodes.length === 0) {\n    return {\n      type: \"comparison\",\n      comparison: {\n        field: \"_id\",\n        operator: \"exists\" as Operator,\n        value: true,\n      },\n    };\n  }\n  if (nodes.length === 1) return nodes[0];\n\n  return { type: \"and\", nodes };\n}\n\n/**\n * Converts ISO date strings to Unix timestamps for Convex compatibility.\n * @internal\n */\nfunction convertDateValue(value: unknown): unknown {\n  // Handle Date objects\n  if (value instanceof Date) {\n    return value.getTime();\n  }\n\n  // Handle ISO date strings\n  if (\n    typeof value === \"string\" &&\n    /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/.test(value)\n  ) {\n    const date = new Date(value);\n    if (!isNaN(date.getTime())) {\n      return date.getTime();\n    }\n  }\n\n  return value;\n}\n\n/**\n * Parses a single field's conditions into WhereNodes.\n * @internal\n */\nfunction parseWhereField(field: string, fieldValue: WhereField): WhereNode[] {\n  const nodes: WhereNode[] = [];\n\n  for (const [operator, value] of Object.entries(fieldValue)) {\n    nodes.push({\n      type: \"comparison\",\n      comparison: {\n        field,\n        operator: operator as Operator,\n        value: convertDateValue(value),\n      },\n    });\n  }\n\n  return nodes;\n}\n\n/**\n * Builds a Convex filter expression from a ParsedWhereFilter.\n * @internal\n */\nexport function buildConvexFilter(\n  q: FilterBuilder<GenericTableInfo>,\n  node: ParsedWhereFilter\n): ExpressionOrValue<boolean> {\n  if (!node) return true;\n  return buildNode(q, node);\n}\n\n/**\n * Recursively builds a filter expression from a WhereNode.\n * @internal\n */\nfunction buildNode(\n  q: FilterBuilder<GenericTableInfo>,\n  node: WhereNode\n): ExpressionOrValue<boolean> {\n  switch (node.type) {\n    case \"and\":\n      if (node.nodes.length === 0) return true;\n      if (node.nodes.length === 1) return buildNode(q, node.nodes[0]);\n      return q.and(...node.nodes.map((n) => buildNode(q, n)));\n\n    case \"or\":\n      if (node.nodes.length === 0) return false;\n      if (node.nodes.length === 1) return buildNode(q, node.nodes[0]);\n      return q.or(...node.nodes.map((n) => buildNode(q, n)));\n\n    case \"not\":\n      return q.not(buildNode(q, node.node));\n\n    case \"comparison\":\n      return buildComparison(q, node.comparison);\n  }\n}\n\n/**\n * Normalizes a single field segment to Convex format.\n * @internal\n */\nfunction normalizeFieldSegment(segment: string): string {\n  if (segment === \"id\") return \"_id\";\n  if (segment === \"_id\") return \"_id\";\n  if (segment === \"createdAt\") return \"_creationTime\";\n  if (segment === \"_creationTime\") return \"_creationTime\";\n  if (segment === \"updatedAt\") return \"_updatedTime\";\n  if (segment === \"_updatedTime\") return \"_updatedTime\";\n  return `payvex_${segment}`;\n}\n\n/**\n * Normalizes Payload field names to Convex field names.\n * @internal\n */\nfunction normalizeField(field: string): string {\n  // Handle nested field paths - prefix each segment\n  if (field.includes(\".\")) {\n    return field.split(\".\").map(normalizeFieldSegment).join(\".\");\n  }\n\n  // Single field - normalize directly\n  return normalizeFieldSegment(field);\n}\n\n/**\n * Builds a filter expression for a single comparison.\n * @internal\n */\nfunction buildComparison(\n  q: FilterBuilder<GenericTableInfo>,\n  cmp: WhereComparison\n): ExpressionOrValue<boolean> {\n  const field = q.field(normalizeField(cmp.field));\n\n  switch (cmp.operator) {\n    case \"equals\":\n      return q.eq(field, cmp.value as any);\n\n    case \"not_equals\":\n      return q.neq(field, cmp.value as any);\n\n    case \"greater_than\":\n      return q.gt(field, cmp.value as any);\n\n    case \"greater_than_equal\":\n      return q.gte(field, cmp.value as any);\n\n    case \"less_than\":\n      return q.lt(field, cmp.value as any);\n\n    case \"less_than_equal\":\n      return q.lte(field, cmp.value as any);\n\n    case \"in\": {\n      if (!Array.isArray(cmp.value) || cmp.value.length === 0) {\n        return false;\n      }\n      return q.or(...cmp.value.map((v) => q.eq(field, v as any)));\n    }\n\n    case \"not_in\": {\n      if (!Array.isArray(cmp.value) || cmp.value.length === 0) {\n        return true;\n      }\n      return q.and(...cmp.value.map((v) => q.neq(field, v as any)));\n    }\n\n    case \"exists\":\n      if (cmp.value === true) {\n        return q.and(q.neq(field, undefined as any), q.neq(field, null as any));\n      }\n      return q.or(q.eq(field, undefined as any), q.eq(field, null as any));\n\n    case \"contains\":\n    case \"like\":\n    case \"near\":\n      throw new Error(\n        `Operator \"${cmp.operator}\" requires post-filtering or custom index. ` +\n          `Field: ${cmp.field}, Value: ${JSON.stringify(cmp.value)}`\n      );\n\n    default:\n      throw new Error(\n        `Unsupported operator: ${cmp.operator} on field ${cmp.field}`\n      );\n  }\n}\n\n/**\n * Gets a nested value from a Convex document using dot notation.\n * @internal\n */\nfunction getNestedValue(obj: any, path: string): any {\n  const parts = path.split(\".\");\n  let current = obj;\n  for (const part of parts) {\n    if (current === null || current === undefined) return undefined;\n    const key = normalizeFieldSegment(part);\n    current = current[key];\n  }\n  return current;\n}\n\n/**\n * Evaluates a comparison against a document.\n * @internal\n */\nfunction evaluateComparison(doc: any, cmp: WhereComparison): boolean {\n  const value = getNestedValue(doc, cmp.field);\n  const compareValue = cmp.value as any;\n\n  switch (cmp.operator) {\n    case \"equals\":\n      return value === compareValue;\n    case \"not_equals\":\n      return value !== compareValue;\n    case \"greater_than\":\n      return value > compareValue;\n    case \"greater_than_equal\":\n      return value >= compareValue;\n    case \"less_than\":\n      return value < compareValue;\n    case \"less_than_equal\":\n      return value <= compareValue;\n    case \"in\":\n      return Array.isArray(compareValue) && compareValue.includes(value);\n    case \"not_in\":\n      return Array.isArray(compareValue) && !compareValue.includes(value);\n    case \"exists\":\n      return compareValue ? value !== undefined : value === undefined;\n    case \"contains\":\n      return (\n        typeof value === \"string\" &&\n        typeof compareValue === \"string\" &&\n        value.includes(compareValue)\n      );\n    case \"like\":\n      if (typeof value !== \"string\" || typeof compareValue !== \"string\")\n        return false;\n      const pattern = compareValue.replace(/%/g, \".*\").replace(/_/g, \".\");\n      return new RegExp(`^${pattern}$`, \"i\").test(value);\n    default:\n      return true;\n  }\n}\n\n/**\n * Evaluates a where node against a document.\n * @internal\n */\nfunction evaluateNode(doc: any, node: WhereNode): boolean {\n  switch (node.type) {\n    case \"and\":\n      return node.nodes.every((n) => evaluateNode(doc, n));\n\n    case \"or\":\n      return node.nodes.some((n) => evaluateNode(doc, n));\n\n    case \"not\":\n      return !evaluateNode(doc, node.node);\n\n    case \"comparison\":\n      return evaluateComparison(doc, node.comparison);\n  }\n}\n\n/**\n * Applies post-processing filter to documents in memory.\n */\nexport function applyPostFilter(\n  documents: any[],\n  postFilter: ParsedWhereFilter,\n  debug: boolean = false\n): any[] {\n  if (!postFilter) return documents;\n\n  if (debug) {\n    console.log(\"[applyPostFilter] Input docs:\", documents.length);\n    console.log(\n      \"[applyPostFilter] Filter:\",\n      JSON.stringify(postFilter, null, 2)\n    );\n  }\n\n  const result = documents.filter((doc) => {\n    const passes = evaluateNode(doc, postFilter);\n    if (debug) {\n      console.log(\"[applyPostFilter] Doc evaluation:\", {\n        docId: doc._id,\n        passes,\n        docKeys: Object.keys(doc).slice(0, 5),\n      });\n    }\n    return passes;\n  });\n\n  if (debug) {\n    console.log(\"[applyPostFilter] Output docs:\", result.length);\n  }\n\n  return result;\n}\n\n/**\n * Applies an enhanced where plan to a Convex query.\n */\nexport function applyWherePlan<T extends any>(\n  baseQuery: T,\n  wherePlan: EnhancedParsedWhereFilter | null | undefined\n): T {\n  if (!wherePlan || !wherePlan.dbFilter) {\n    return baseQuery;\n  }\n\n  // Apply DB filter\n  return (baseQuery as any).filter((q: any) => {\n    const expr = buildConvexFilter(q, wherePlan.dbFilter);\n    if (expr === true) return true;\n    if (expr === false) return false;\n    return expr;\n  }) as T;\n}\n\n// ============================================================================\n// Data Compilation (migrated from data-compiler.ts)\n// ============================================================================\n\n/**\n * Generic type representing any data object.\n */\nexport type PayloadData = Record<string, any>;\n\n/**\n * Generic type representing any data object in Convex format.\n */\nexport type ConvexData = Record<string, any>;\n\n/**\n * Key transformer function type.\n */\nexport type KeyTransformer = (key: string) => string;\n\n/**\n * Value transformer function type.\n */\nexport type ValueTransformer = (value: any, key: string) => any;\n\n/**\n * Default key transformer for Payload to Convex.\n * Prefixes all keys with `payvex_` to avoid conflicts with Convex reserved fields.\n */\nconst defaultKeyToConvex: KeyTransformer = (key: string): string => {\n  // Skip Convex system fields that should not be prefixed\n  if (key === \"_id\" || key === \"_creationTime\") {\n    return key;\n  }\n  // Prefix all other keys with payvex_\n  return `payvex_${key}`;\n};\n\n/**\n * Default key transformer for Convex to Payload.\n * Transforms Convex system fields to Payload format and removes the `payvex_` prefix.\n */\nconst defaultKeyToPayload: KeyTransformer = (key: string): string => {\n  // Transform Convex system fields to Payload format\n  if (key === \"_id\") return \"id\";\n  if (key === \"_creationTime\") return \"createdAt\";\n  if (key === \"_updatedTime\") return \"updatedAt\";\n\n  // Remove payvex_ prefix if present\n  if (key.startsWith(\"payvex_\")) {\n    return key.replace(\"payvex_\", \"\");\n  }\n  return key;\n};\n\n/**\n * Default value transformer (pass-through).\n */\nconst defaultValueTransformer: ValueTransformer = (value: any) => value;\n\n/**\n * Recursively transforms a value from Payload to Convex format.\n */\nfunction transformValueToConvex(value: any, key: string = \"\"): any {\n  // Handle null/undefined\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  // Handle Date objects - convert to Unix timestamp (number)\n  if (value instanceof Date) {\n    return value.getTime();\n  }\n\n  // Handle arrays - recursively transform elements\n  if (Array.isArray(value)) {\n    return value\n      .filter((item) => item !== undefined)\n      .map((item, index) => transformValueToConvex(item, `${key}[${index}]`));\n  }\n\n  // Handle nested objects - recursively transform\n  if (typeof value === \"object\") {\n    return transformObjectToConvex(value);\n  }\n\n  // Handle ISO date strings - convert to Unix timestamp (number)\n  if (\n    typeof value === \"string\" &&\n    /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/.test(value)\n  ) {\n    const date = new Date(value);\n    if (!isNaN(date.getTime())) {\n      return date.getTime();\n    }\n  }\n\n  return value;\n}\n\n/**\n * Transforms an object from Payload to Convex format.\n */\nfunction transformObjectToConvex(obj: PayloadData): ConvexData {\n  const result: ConvexData = {};\n\n  for (const [originalKey, value] of Object.entries(obj)) {\n    const transformedKey = defaultKeyToConvex(originalKey);\n    const transformedValue = transformValueToConvex(value, transformedKey);\n    result[transformedKey] = transformedValue;\n  }\n\n  return result;\n}\n\n/**\n * Recursively transforms a value from Convex to Payload format.\n */\nfunction transformValueToPayload(value: any, key: string = \"\"): any {\n  // Handle null/undefined\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  // Handle timestamps - convert back to ISO strings for user date fields\n  if (\n    typeof value === \"number\" &&\n    key !== \"_creationTime\" && // Don't convert Convex system field\n    key !== \"_id\" && // Don't convert IDs\n    (key.toLowerCase().includes(\"at\") ||\n      key.toLowerCase().includes(\"date\") ||\n      key.toLowerCase().includes(\"time\"))\n  ) {\n    // Check if it's a reasonable timestamp (between year 2000 and 2100)\n    const year2000 = 946684800000; // Jan 1, 2000\n    const year2100 = 4102444800000; // Jan 1, 2100\n    if (value >= year2000 && value <= year2100) {\n      return new Date(value).toISOString();\n    }\n  }\n\n  // Handle arrays - recursively transform elements\n  if (Array.isArray(value)) {\n    return value.map((item, index) =>\n      transformValueToPayload(item, `${key}[${index}]`)\n    );\n  }\n\n  // Handle nested objects - recursively transform\n  if (typeof value === \"object\" && !(value instanceof Date)) {\n    return transformObjectToPayload(value);\n  }\n\n  return value;\n}\n\n/**\n * Transforms an object from Convex to Payload format.\n */\nfunction transformObjectToPayload(obj: ConvexData): PayloadData {\n  const result: PayloadData = {};\n\n  for (const [originalKey, value] of Object.entries(obj)) {\n    const transformedKey = defaultKeyToPayload(originalKey);\n    const transformedValue = transformValueToPayload(value, transformedKey);\n    result[transformedKey] = transformedValue;\n  }\n\n  return result;\n}\n\n/**\n * Transforms data from Payload format to Convex format.\n */\nfunction compileToConvex<T>(data: T): T {\n  if (data === null || data === undefined) {\n    return data;\n  }\n  if (Array.isArray(data)) {\n    return data.map((doc) => transformObjectToConvex(doc)) as T;\n  }\n  if (typeof data === \"object\") {\n    return transformObjectToConvex(data as PayloadData) as T;\n  }\n  return data;\n}\n\n/**\n * Transforms data from Convex format to Payload format.\n */\nfunction compileToPayload<T>(data: T | null | undefined): T | null | undefined {\n  if (data === null || data === undefined) {\n    return data;\n  }\n  if (Array.isArray(data)) {\n    return data.map((doc) => transformObjectToPayload(doc)) as T;\n  }\n  if (typeof data === \"object\") {\n    return transformObjectToPayload(data as ConvexData) as T;\n  }\n  return data;\n}\n\n/**\n * Transforms a paginated result from Convex format to Payload format.\n */\nfunction compilePaginatedToPayload<T>(result: {\n  page: T[];\n  continueCursor: string;\n  isDone: boolean;\n}): { page: T[]; continueCursor: string; isDone: boolean } {\n  return {\n    ...result,\n    page: result.page.map((doc) => transformObjectToPayload(doc as any)) as T[],\n  };\n}\n\n// ============================================================================\n// Convex Query Normalization\n// ============================================================================\n\n/**\n * Props for normalizing a Convex query with collection and index configuration.\n */\nexport type NormalizeConvexQueryProps = {\n  ctx: GenericQueryCtx<GenericDataModel>;\n  service: AdapterService;\n  collection: string;\n  index?: AdapaterQueryIndex;\n};\n\n/**\n * @function normalizeConvexQuery\n * Normalizes a Convex query by applying collection prefix and optional index configuration.\n * This is the foundation for all collection-based queries.\n *\n * @param {NormalizeConvexQueryProps} props - The query configuration\n * @param {GenericQueryCtx<GenericDataModel>} props.ctx - The Convex query context\n * @param {AdapterService} props.service - The adapter service instance\n * @param {string} props.collection - The collection name to query\n * @param {AdapaterQueryIndex} props.index - Optional index configuration\n * @returns {Query} A Convex query builder configured with collection and index\n */\nexport function normalizeConvexQuery(props: NormalizeConvexQueryProps) {\n  const { ctx, service, collection, index } = props;\n\n  const collectionId = service.tools.parseCollection({\n    prefix: service.system.prefix,\n    collection: collection,\n  });\n\n  if (index) {\n    if (typeof index.indexRange === \"function\") {\n      return ctx.db\n        .query(collectionId)\n        .withIndex(index.indexName, index.indexRange);\n    } else {\n      return ctx.db\n        .query(collectionId)\n        .withIndex(index.indexName, (q: any) => q);\n    }\n  }\n  return ctx.db.query(collectionId);\n}\n\n// ============================================================================\n// Chainable API Type Definitions\n// ============================================================================\n\n/**\n * Chainable query builder for Convex operations.\n * Enables fluent API: processor.query().filter().postFilter().toPayload()\n */\nexport type ConvexQueryChain = {\n  /**\n   * Apply DB-level filter from wherePlan.\n   * Called automatically by query() if wherePlan has dbFilter.\n   */\n  filter(): ConvexQueryChain;\n\n  /**\n   * Mark for post-filter processing after collect.\n   */\n  postFilter(): ConvexQueryChain;\n\n  /**\n   * Apply ordering to the query.\n   */\n  order(direction: \"asc\" | \"desc\"): ConvexQueryChain;\n\n  /**\n   * Limit results to n documents.\n   */\n  take(n: number): ConvexQueryChain;\n\n  /**\n   * Switch to paginated mode.\n   */\n  paginate(opts: PaginationOptions): ConvexPaginatedChain;\n\n  /**\n   * Execute query and return raw Convex documents.\n   */\n  collect<T = any>(): Promise<T[]>;\n\n  /**\n   * Execute query and return Payload-formatted documents.\n   */\n  toPayload<T = any>(): Promise<T[]>;\n\n  /**\n   * Execute query and return the first matching document.\n   */\n  first<T = any>(): Promise<T | null>;\n};\n\n/**\n * Chainable paginated query builder.\n */\nexport type ConvexPaginatedChain = {\n  /**\n   * Mark for post-filter processing.\n   */\n  postFilter(): ConvexPaginatedChain;\n\n  /**\n   * Execute and return raw Convex paginated result.\n   */\n  collect<T = any>(): Promise<{\n    page: T[];\n    continueCursor: string;\n    isDone: boolean;\n  }>;\n\n  /**\n   * Execute and return Payload-formatted paginated result.\n   */\n  toPayload<T = any>(): Promise<{\n    page: T[];\n    continueCursor: string;\n    isDone: boolean;\n  }>;\n};\n\n/**\n * Internal state for the query chain.\n */\ntype QueryChainState = {\n  ctx: GenericQueryCtx<GenericDataModel> | GenericMutationCtx<GenericDataModel>;\n  service: AdapterService;\n  collection: string;\n  wherePlan?: EnhancedParsedWhereFilter;\n  index?: AdapaterQueryIndex;\n\n  // Chain state\n  baseQuery: any;\n  shouldPostFilter: boolean;\n  orderDirection?: \"asc\" | \"desc\";\n  takeLimit?: number;\n};\n\n// ============================================================================\n// Type Definitions\n// ============================================================================\n\n/**\n * Processed output for Convex operations.\n * Contains all the data needed to execute a Convex query/mutation.\n */\nexport type ProcessedConvexQueryProps = {\n  /** Prefixed collection ID */\n  collection: string;\n  /** Parsed where filter with hybrid filtering support */\n  wherePlan: EnhancedParsedWhereFilter;\n  /** Compiled data safe for Convex (with payvex_ prefix, dates as timestamps) */\n  data?: Record<string, unknown>;\n  /** Limit for query results */\n  limit?: number;\n  /** Sort order */\n  order?: \"asc\" | \"desc\";\n  /** Pagination options */\n  paginationOpts?: { numItems: number; cursor: string | null };\n  /** Optional index configuration */\n  index?: AdapaterQueryIndex;\n};\n\n/**\n * Adapter-side QueryProcessor result.\n * Provides convexQueryProps to pass to Convex and methods to process results.\n */\nexport type AdapterQueryProcessor = {\n  /** Processed query props ready to pass to Convex */\n  convexQueryProps: ProcessedConvexQueryProps;\n  /** Process results from Convex back to Payload format */\n  processResult<T>(result: T): T;\n  /** Process Convex query results (alias for processResult) */\n  processConvexQueryResult<T>(result: T): T;\n  /** Process paginated results from Convex */\n  processPaginatedResult<T>(result: {\n    page: T[];\n    continueCursor: string;\n    isDone: boolean;\n  }): { page: T[]; continueCursor: string; isDone: boolean };\n  /** Compile data to Convex format (for direct use) */\n  compileToConvex<T>(data: T): T;\n  /** Compile data to Payload format (for direct use) */\n  compileToPayload<T>(data: T): T;\n};\n\n/**\n * Convex-side QueryProcessor result.\n * Provides chainable query building API.\n */\nexport type ConvexQueryProcessor = {\n  /**\n   * Start building a query chain.\n   * Automatically applies collection and index configuration.\n   */\n  query(): ConvexQueryChain;\n\n  /**\n   * Direct access to apply post-filter on existing results.\n   * Useful when you need manual control.\n   */\n  applyPostFilter<T>(results: T[], wherePlan?: EnhancedParsedWhereFilter): T[];\n\n  /**\n   * Transform Convex document(s) to Payload format.\n   */\n  toPayload<T>(data: T): T;\n\n  /** @deprecated Use query() chain instead */\n  processWherePlan(context: {\n    ctx:\n      | GenericQueryCtx<GenericDataModel>\n      | GenericMutationCtx<GenericDataModel>;\n    service: AdapterService;\n    wherePlan: EnhancedParsedWhereFilter;\n    collection: string;\n    index?: AdapaterQueryIndex;\n  }): ReturnType<\n    typeof applyWherePlan<ReturnType<typeof normalizeConvexQuery>>\n  >;\n};\n\n/**\n * Input props for adapter-side QueryProcessor.\n */\nexport type AdapterQueryProcessorProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** Collection name (will be prefixed) */\n  collection: string;\n  /** Payload where clause (will be parsed) */\n  where?: Where;\n  /** Pre-parsed where filter (alternative to where) */\n  wherePlan?: EnhancedParsedWhereFilter;\n  /** Payload data (will be compiled to Convex format) */\n  data?: Record<string, unknown>;\n  /** Query limit */\n  limit?: number;\n  /** Sort string (e.g., \"-createdAt\" for desc, \"createdAt\" for asc) */\n  sort?: string | string[];\n  /** Sort order (alternative to sort string) */\n  order?: \"asc\" | \"desc\";\n  /** Pagination enabled flag */\n  pagination?: boolean;\n  /** Page number (for pagination) */\n  page?: number;\n  /** Optional index configuration */\n  index?: AdapaterQueryIndex;\n  /** Join query configuration for related documents */\n  joins?: JoinQuery;\n  /** Locale for localized content filtering */\n  locale?: string;\n  /** Field selection/projection */\n  select?: SelectType;\n  /** Enable draft document filtering */\n  draftsEnabled?: boolean;\n  /** Enable version document filtering */\n  versions?: boolean;\n  /** Field projection (alternative to select) */\n  projection?: Record<string, unknown>;\n  /** Convex mode flag - must be false for adapter-side */\n  convex: false;\n};\n\n/**\n * Input props for Convex-side QueryProcessor.\n * Now includes all context needed for query building.\n */\nexport type ConvexQueryProcessorProps = {\n  /** Convex query/mutation context */\n  ctx: GenericQueryCtx<GenericDataModel> | GenericMutationCtx<GenericDataModel>;\n  /** The adapter service instance */\n  service: AdapterService;\n  /** Collection name (already prefixed by adapter) */\n  collection: string;\n  /** Parsed where filter from adapter */\n  wherePlan?: EnhancedParsedWhereFilter;\n  /** Optional index configuration */\n  index?: AdapaterQueryIndex;\n  /** Convex mode flag - must be true */\n  convex: true;\n};\n\n// ============================================================================\n// Adapter-Side QueryProcessor\n// ============================================================================\n\n/**\n * Creates an adapter-side QueryProcessor.\n * Runs on the client/adapter side before sending to Convex.\n *\n * @param {AdapterQueryProcessorProps} props - The processor configuration\n * @returns {AdapterQueryProcessor} The processor instance\n *\n * @example\n * ```typescript\n * const processedQuery = queryProcessor({\n *   service,\n *   collection: 'posts',\n *   where: { status: { equals: 'published' } },\n *   data: { title: 'Hello' },\n *   limit: 10,\n *   sort: '-createdAt',\n *   convex: false,\n * });\n *\n * const result = await client.query(api.adapter.collectionWhereQuery,\n *   processedQuery.convexQueryProps\n * );\n *\n * return processedQuery.processResult(result);\n * ```\n */\nfunction createAdapterQueryProcessor(\n  props: AdapterQueryProcessorProps\n): AdapterQueryProcessor {\n  const {\n    service,\n    collection,\n    where,\n    wherePlan: inputWherePlan,\n    data,\n    limit,\n    sort,\n    order: inputOrder,\n    pagination,\n    page,\n    index,\n  } = props;\n\n  // 1. Process collection name with prefix\n  const collectionId = parseCollection({\n    prefix: service.system.prefix,\n    collection,\n  });\n\n  // 2. Process where clause into WherePlan (use pre-parsed if provided)\n  const wherePlan = inputWherePlan || parsePayloadWhere(where);\n\n  // 3. Transform data to Convex-safe format (apply payvex_ prefix, convert dates)\n  const compiledData = data ? compileToConvex(data) : undefined;\n\n  // 4. Process sort into order (use direct order if provided)\n  const order: \"asc\" | \"desc\" =\n    inputOrder ||\n    (typeof sort === \"string\" && sort.startsWith(\"-\") ? \"desc\" : \"asc\");\n\n  // 5. Build pagination options if needed\n  let paginationOpts: { numItems: number; cursor: string | null } | undefined;\n  if (pagination && limit && page) {\n    paginationOpts = {\n      numItems: limit,\n      cursor: null, // TODO: Support cursor-based pagination\n    };\n  }\n\n  // 6. Build convex query props\n  const convexQueryProps: ProcessedConvexQueryProps = {\n    collection: collectionId,\n    wherePlan,\n    data: compiledData,\n    limit,\n    order,\n    paginationOpts,\n    index,\n  };\n\n  return {\n    convexQueryProps,\n\n    // Process results from Convex back to Payload format\n    processResult<T>(result: T): T {\n      const compiled = compileToPayload(result);\n      return (compiled ?? result) as T;\n    },\n\n    processConvexQueryResult<T>(result: T): T {\n      const compiled = compileToPayload(result);\n      return (compiled ?? result) as T;\n    },\n\n    // Helper for paginated results\n    processPaginatedResult<T>(result: {\n      page: T[];\n      continueCursor: string;\n      isDone: boolean;\n    }) {\n      return compilePaginatedToPayload(result);\n    },\n\n    // Direct compilation methods\n    compileToConvex<T>(data: T): T {\n      const compiled = compileToConvex(data);\n      return (compiled ?? data) as T;\n    },\n\n    compileToPayload<T>(data: T): T {\n      const compiled = compileToPayload(data);\n      return (compiled ?? data) as T;\n    },\n  };\n}\n\n// ============================================================================\n// Chainable Query Implementation\n// ============================================================================\n\n/**\n * Creates a ConvexQueryChain with chainable methods.\n */\nfunction createQueryChain(state: QueryChainState): ConvexQueryChain {\n  const chain: ConvexQueryChain = {\n    filter(): ConvexQueryChain {\n      // Apply DB filter from wherePlan if available\n      if (state.wherePlan?.dbFilter) {\n        state.baseQuery = applyWherePlan(state.baseQuery, state.wherePlan);\n      }\n      return chain;\n    },\n\n    postFilter(): ConvexQueryChain {\n      state.shouldPostFilter = true;\n      return chain;\n    },\n\n    order(direction: \"asc\" | \"desc\"): ConvexQueryChain {\n      state.orderDirection = direction;\n      return chain;\n    },\n\n    take(n: number): ConvexQueryChain {\n      state.takeLimit = n;\n      return chain;\n    },\n\n    paginate(opts: PaginationOptions): ConvexPaginatedChain {\n      return createPaginatedChain(state, opts);\n    },\n\n    async collect<T>(): Promise<T[]> {\n      let query = state.baseQuery;\n\n      // Apply ordering if specified\n      if (state.orderDirection) {\n        query = query.order(state.orderDirection);\n      }\n\n      // Execute query\n      let results: T[];\n      if (state.takeLimit !== undefined) {\n        results = await query.take(state.takeLimit);\n      } else {\n        results = await query.collect();\n      }\n\n      // Apply post-filter if marked\n      if (state.shouldPostFilter && state.wherePlan?.postFilter) {\n        results = applyPostFilter(results, state.wherePlan.postFilter) as T[];\n      }\n\n      return results;\n    },\n\n    async toPayload<T>(): Promise<T[]> {\n      const results = await chain.collect<T>();\n      return compileToPayload(results) as T[];\n    },\n\n    async first<T>(): Promise<T | null> {\n      const results = await chain.take(1).collect<T>();\n      return results.length > 0 ? results[0] : null;\n    },\n  };\n\n  return chain;\n}\n\n/**\n * Creates a ConvexPaginatedChain for paginated queries.\n */\nfunction createPaginatedChain(\n  state: QueryChainState,\n  paginationOpts: PaginationOptions\n): ConvexPaginatedChain {\n  let shouldPostFilter = state.shouldPostFilter;\n\n  const chain: ConvexPaginatedChain = {\n    postFilter(): ConvexPaginatedChain {\n      shouldPostFilter = true;\n      return chain;\n    },\n\n    async collect<T>(): Promise<{\n      page: T[];\n      continueCursor: string;\n      isDone: boolean;\n    }> {\n      let query = state.baseQuery;\n\n      // Apply ordering if specified\n      if (state.orderDirection) {\n        query = query.order(state.orderDirection);\n      }\n\n      // Execute paginated query\n      const result = await query.paginate(paginationOpts);\n\n      // Apply post-filter if marked\n      if (shouldPostFilter && state.wherePlan?.postFilter) {\n        return {\n          ...result,\n          page: applyPostFilter(result.page, state.wherePlan.postFilter) as T[],\n        };\n      }\n\n      return result;\n    },\n\n    async toPayload<T>(): Promise<{\n      page: T[];\n      continueCursor: string;\n      isDone: boolean;\n    }> {\n      const result = await chain.collect<T>();\n      return compilePaginatedToPayload(result);\n    },\n  };\n\n  return chain;\n}\n\n// ============================================================================\n// Convex-Side QueryProcessor\n// ============================================================================\n\n/**\n * Creates a Convex-side QueryProcessor with chainable API.\n * Runs inside Convex query/mutation handlers.\n *\n * @param {ConvexQueryProcessorProps} props - The processor configuration\n * @returns {ConvexQueryProcessor} The processor instance\n *\n * @example\n * ```typescript\n * const processor = queryProcessor({\n *   ctx, service, collection, wherePlan, index, convex: true\n * });\n * const results = await processor.query().postFilter().toPayload();\n * ```\n */\nfunction createConvexQueryProcessor(\n  props: ConvexQueryProcessorProps\n): ConvexQueryProcessor {\n  const { ctx, service, collection, wherePlan, index } = props;\n\n  return {\n    query(): ConvexQueryChain {\n      // Build the base Convex query with collection and optional index\n      const baseQuery = normalizeConvexQuery({\n        ctx: ctx as GenericQueryCtx<GenericDataModel>,\n        service,\n        collection,\n        index,\n      });\n\n      // Create initial chain state\n      const state: QueryChainState = {\n        ctx,\n        service,\n        collection,\n        wherePlan,\n        index,\n        baseQuery,\n        shouldPostFilter: false,\n      };\n\n      // Return chain with filter already applied if wherePlan has dbFilter\n      const chain = createQueryChain(state);\n\n      // Auto-apply DB filter if present\n      if (wherePlan?.dbFilter) {\n        return chain.filter();\n      }\n\n      return chain;\n    },\n\n    applyPostFilter<T>(results: T[], plan?: EnhancedParsedWhereFilter): T[] {\n      const effectivePlan = plan || wherePlan;\n      if (effectivePlan?.postFilter) {\n        return applyPostFilter(results, effectivePlan.postFilter) as T[];\n      }\n      return results;\n    },\n\n    toPayload<T>(data: T): T {\n      return compileToPayload(data) as T;\n    },\n\n    // Legacy method for backward compatibility\n    processWherePlan<T extends any>(context: {\n      ctx:\n        | GenericQueryCtx<GenericDataModel>\n        | GenericMutationCtx<GenericDataModel>;\n      service: AdapterService;\n      wherePlan: EnhancedParsedWhereFilter;\n      collection: string;\n      index?: AdapaterQueryIndex;\n    }): T {\n      const {\n        ctx: contextCtx,\n        service: contextService,\n        wherePlan: contextWherePlan,\n        collection: contextCollection,\n        index: contextIndex,\n      } = context;\n\n      // Build base query with collection prefix\n      const baseQuery = normalizeConvexQuery({\n        ctx: contextCtx as GenericQueryCtx<GenericDataModel>,\n        service: contextService,\n        collection: contextCollection,\n        index: contextIndex,\n      });\n\n      // Apply DB filter from wherePlan\n      const filtered = applyWherePlan(baseQuery, contextWherePlan);\n\n      return filtered as T;\n    },\n  };\n}\n\n// ============================================================================\n// Unified QueryProcessor API\n// ============================================================================\n\n/**\n * Creates a QueryProcessor for bidirectional Payload-Convex transformation.\n *\n * The QueryProcessor integrates compileToConvex, compileToPayload, and\n * parsePayloadWhere into a unified API. It operates in two modes:\n *\n * - **Adapter-side (convex: false)**: Prepares data and queries for Convex\n * - **Convex-side (convex: true)**: Processes queries and filters inside Convex\n *\n * @param {AdapterQueryProcessorProps | ConvexQueryProcessorProps} props - The processor configuration\n * @returns {AdapterQueryProcessor | ConvexQueryProcessor} The processor instance\n *\n * @example Adapter-side usage:\n * ```typescript\n * const processedQuery = service.tools.queryProcessor({\n *   service,\n *   collection: 'posts',\n *   where: payloadWhere,\n *   data: documentData,\n *   limit: 10,\n *   convex: false,\n * });\n *\n * const result = await client.query(api.adapter.collectionWhereQuery,\n *   processedQuery.convexQueryProps\n * );\n *\n * return processedQuery.processResult(result);\n * ```\n *\n * @example Convex-side usage:\n * ```typescript\n * const processor = service.tools.queryProcessor({ convex: true });\n *\n * const filtered = processor.processWherePlan({\n *   ctx,\n *   service,\n *   wherePlan: args.wherePlan,\n *   collection: args.collection,\n *   index: args.index,\n * });\n *\n * let results = await filtered.collect();\n * results = processor.applyPostFilter(results, args.wherePlan);\n * ```\n */\nexport function queryProcessor(\n  props: AdapterQueryProcessorProps\n): AdapterQueryProcessor;\nexport function queryProcessor(\n  props: ConvexQueryProcessorProps\n): ConvexQueryProcessor;\nexport function queryProcessor(\n  props: AdapterQueryProcessorProps | ConvexQueryProcessorProps\n): AdapterQueryProcessor | ConvexQueryProcessor {\n  if (props.convex === false) {\n    return createAdapterQueryProcessor(props as AdapterQueryProcessorProps);\n  }\n  return createConvexQueryProcessor(props as ConvexQueryProcessorProps);\n}\n","/**\n * @fileoverview Random ID Generation\n *\n * This module provides UUID generation for creating unique identifiers\n * throughout the adapter. Uses UUID v4 for cryptographically secure\n * random ID generation.\n *\n * @module utils/random\n */\n\nimport { v4 as uuidv4 } from \"uuid\";\n\n/**\n * Creates a random UUID v4 identifier.\n *\n * Used for generating unique IDs for transactions, sessions, and\n * other entities that require unique identification.\n *\n * @returns {string} A UUID v4 string\n *\n * @example\n * ```typescript\n * const id = createRandomID();\n * // \"550e8400-e29b-41d4-a716-446655440000\"\n * ```\n */\nexport function createRandomID() {\n  return uuidv4();\n}\n","/**\n * @fileoverview Session Tracker for Transaction Management\n *\n * This module provides a session tracking system for managing database\n * transactions. Sessions track the lifecycle of transactions from creation\n * through completion (commit or rollback).\n *\n * ## Session States\n * - **idle**: Session created but not started\n * - **in-progress**: Session is active and tracking operations\n * - **resolved**: Session was committed successfully\n * - **rejected**: Session was rolled back\n *\n * ## Usage\n * ```typescript\n * const tracker = createSessionTracker();\n * const session = tracker.createSession('tx-123');\n * tracker.startSession('tx-123');\n * // Track operations...\n * tracker.resolveSession('tx-123'); // or rejectSession\n * tracker.deleteSession('tx-123');\n * ```\n *\n * @module utils/session-tracker\n */\n\n/**\n * Possible states for a transaction session.\n */\nexport type SessionState = \"idle\" | \"in-progress\" | \"resolved\" | \"rejected\";\n\n/**\n * Types of query operations that can be tracked.\n */\nexport type QueryOperationType =\n  | \"getById\"\n  | \"collectionQuery\"\n  | \"collectionFilterQuery\"\n  | \"collectionFilterOrderQuery\"\n  | \"collectionFilterOrderLimitQuery\"\n  | \"collectionOrderQuery\"\n  | \"collectionLimitQuery\"\n  | \"collectionOrderLimitQuery\"\n  | \"collectionFilterLimitQuery\"\n  | \"collectionFilterPaginateQuery\"\n  | \"collectionOrderPaginateQuery\"\n  | \"collectionFilterOrderPaginateQuery\";\n\n/**\n * Types of mutation operations that can be tracked.\n */\nexport type MutationOperationType =\n  | \"insert\"\n  | \"getById\"\n  | \"patch\"\n  | \"replace\"\n  | \"delete\"\n  | \"upsert\"\n  | \"updateMany\"\n  | \"deleteMany\"\n  | \"increment\"\n  | \"transactional\";\n\n/**\n * Union type of all database operation types.\n */\nexport type DatabaseOperationType = QueryOperationType | MutationOperationType;\n\n/**\n * Represents a tracked database operation within a session.\n * Stores all information needed for potential rollback.\n */\nexport type DatabaseOperation = {\n  id: string;\n  type: DatabaseOperationType;\n  timestamp: Date;\n  projectPrefix: string;\n  collection: string;\n  // For mutations that modify data, store the original state for rollback\n  originalData?: any;\n  // For mutations, store the new data\n  newData?: any;\n  // For operations with IDs\n  documentId?: string;\n  // For filter-based operations\n  filter?: any;\n  // For operations with additional params\n  params?: Record<string, any>;\n};\n\n/**\n * Represents a transaction session with its state and tracked operations.\n */\nexport type Session = {\n  /** Unique session identifier */\n  id: string;\n  /** Current state of the session */\n  state: SessionState;\n  /** When the session was created */\n  createdAt: Date;\n  /** When the session was started (transitioned to in-progress) */\n  startedAt?: Date;\n  /** When the session was resolved (committed) */\n  resolvedAt?: Date;\n  /** When the session was rejected (rolled back) */\n  rejectedAt?: Date;\n  /** List of tracked database operations */\n  operations: DatabaseOperation[];\n};\n\n/**\n * Interface for the session tracker.\n * Provides methods for managing transaction sessions and their operations.\n */\nexport type SessionTracker = {\n  /**\n   * Create a new transaction session\n   * @param id - Unique session identifier\n   * @returns The created session\n   * @throws Error if session already exists\n   */\n  createSession: (id: string) => Session;\n\n  /**\n   * Get an existing session by ID\n   * @param id - Session identifier\n   * @returns The session if found, undefined otherwise\n   */\n  getSession: (id: string) => Session | undefined;\n\n  /**\n   * Check if a session exists\n   * @param id - Session identifier\n   * @returns true if session exists, false otherwise\n   */\n  hasSession: (id: string) => boolean;\n\n  /**\n   * Start a session (transition from idle to in-progress)\n   * @param id - Session identifier\n   * @returns The started session\n   * @throws Error if session doesn't exist or is not in idle state\n   */\n  startSession: (id: string) => Session;\n\n  /**\n   * Resolve (commit) a transaction session\n   * @param id - Session identifier\n   * @returns The resolved session\n   * @throws Error if session doesn't exist or is not in in-progress state\n   */\n  resolveSession: (id: string) => Session;\n\n  /**\n   * Reject (rollback) a transaction session\n   * @param id - Session identifier\n   * @returns The rejected session\n   * @throws Error if session doesn't exist or is not in in-progress state\n   */\n  rejectSession: (id: string) => Session;\n\n  /**\n   * Delete a session from the tracker\n   * @param id - Session identifier\n   * @returns true if session was deleted, false if it didn't exist\n   */\n  deleteSession: (id: string) => boolean;\n\n  /**\n   * Get all idle sessions\n   * @returns Array of idle sessions\n   */\n  getIdleSessions: () => Session[];\n\n  /**\n   * Get all active (in-progress) sessions\n   * @returns Array of in-progress sessions\n   */\n  getInProgressSessions: () => Session[];\n\n  /**\n   * Get all sessions\n   * @returns Array of all sessions\n   */\n  getAllSessions: () => Session[];\n\n  /**\n   * Clear all sessions\n   */\n  clearAll: () => void;\n\n  /**\n   * Get the number of idle sessions\n   * @returns Count of idle sessions\n   */\n  getIdleCount: () => number;\n\n  /**\n   * Get the number of active (in-progress) sessions\n   * @returns Count of in-progress sessions\n   */\n  getInProgressCount: () => number;\n\n  /**\n   * Track a database operation for a session\n   * @param sessionId - Session identifier\n   * @param operation - Database operation to track\n   * @returns The tracked operation\n   * @throws Error if session doesn't exist or is not in in-progress state\n   */\n  trackOperation: (\n    sessionId: string,\n    operation: Omit<DatabaseOperation, \"id\" | \"timestamp\">,\n  ) => DatabaseOperation;\n\n  /**\n   * Get all operations for a session\n   * @param sessionId - Session identifier\n   * @returns Array of operations for the session\n   * @throws Error if session doesn't exist\n   */\n  getSessionOperations: (sessionId: string) => DatabaseOperation[];\n\n  /**\n   * Get operations for a session by type\n   * @param sessionId - Session identifier\n   * @param type - Operation type to filter by\n   * @returns Array of operations matching the type\n   * @throws Error if session doesn't exist\n   */\n  getSessionOperationsByType: (\n    sessionId: string,\n    type: DatabaseOperationType,\n  ) => DatabaseOperation[];\n\n  /**\n   * Get operations for a session by collection\n   * @param sessionId - Session identifier\n   * @param collection - Collection name to filter by\n   * @returns Array of operations for the collection\n   * @throws Error if session doesn't exist\n   */\n  getSessionOperationsByCollection: (\n    sessionId: string,\n    collection: string,\n  ) => DatabaseOperation[];\n\n  /**\n   * Clear all operations for a session\n   * @param sessionId - Session identifier\n   * @returns true if operations were cleared, false if session doesn't exist\n   */\n  clearSessionOperations: (sessionId: string) => boolean;\n};\n\n/**\n * Creates a new session tracker instance.\n *\n * The session tracker manages transaction sessions, tracking their lifecycle\n * and associated database operations. It provides methods for creating,\n * starting, resolving, and rejecting sessions, as well as tracking operations.\n *\n * @returns {SessionTracker} A new session tracker instance\n *\n * @example\n * ```typescript\n * const tracker = createSessionTracker();\n *\n * // Create and start a session\n * const session = tracker.createSession('tx-123');\n * tracker.startSession('tx-123');\n *\n * // Track an operation\n * tracker.trackOperation('tx-123', {\n *   type: 'insert',\n *   projectPrefix: 'my_app',\n *   collection: 'users',\n *   newData: { name: 'John' },\n * });\n *\n * // Commit or rollback\n * tracker.resolveSession('tx-123');\n * tracker.deleteSession('tx-123');\n * ```\n */\nexport function createSessionTracker(): SessionTracker {\n  const sessions = new Map<string, Session>();\n\n  const createSession = (id: string): Session => {\n    if (sessions.has(id)) {\n      throw new Error(`Session ${id} already exists`);\n    }\n\n    const session: Session = {\n      id,\n      state: \"idle\",\n      createdAt: new Date(),\n      operations: [],\n    };\n\n    sessions.set(id, session);\n    return session;\n  };\n\n  const getSession = (id: string): Session | undefined => {\n    return sessions.get(id);\n  };\n\n  const hasSession = (id: string): boolean => {\n    return sessions.has(id);\n  };\n\n  const startSession = (id: string): Session => {\n    const session = sessions.get(id);\n\n    if (!session) {\n      throw new Error(`Session ${id} not found`);\n    }\n\n    if (session.state !== \"idle\") {\n      throw new Error(\n        `Cannot start session ${id}: session is already ${session.state}`,\n      );\n    }\n\n    session.state = \"in-progress\";\n    session.startedAt = new Date();\n\n    return session;\n  };\n\n  const resolveSession = (id: string): Session => {\n    const session = sessions.get(id);\n\n    if (!session) {\n      throw new Error(`Session ${id} not found`);\n    }\n\n    if (session.state !== \"in-progress\") {\n      throw new Error(\n        `Cannot resolve session ${id}: session is ${session.state}, expected in-progress`,\n      );\n    }\n\n    session.state = \"resolved\";\n    session.resolvedAt = new Date();\n\n    return session;\n  };\n\n  const rejectSession = (id: string): Session => {\n    const session = sessions.get(id);\n\n    if (!session) {\n      throw new Error(`Session ${id} not found`);\n    }\n\n    if (session.state !== \"in-progress\") {\n      throw new Error(\n        `Cannot reject session ${id}: session is ${session.state}, expected in-progress`,\n      );\n    }\n\n    session.state = \"rejected\";\n    session.rejectedAt = new Date();\n\n    return session;\n  };\n\n  const deleteSession = (id: string): boolean => {\n    return sessions.delete(id);\n  };\n\n  const getIdleSessions = (): Session[] => {\n    return Array.from(sessions.values()).filter(\n      (session) => session.state === \"idle\",\n    );\n  };\n\n  const getInProgressSessions = (): Session[] => {\n    return Array.from(sessions.values()).filter(\n      (session) => session.state === \"in-progress\",\n    );\n  };\n\n  const getAllSessions = (): Session[] => {\n    return Array.from(sessions.values());\n  };\n\n  const clearAll = (): void => {\n    sessions.clear();\n  };\n\n  const getIdleCount = (): number => {\n    return getIdleSessions().length;\n  };\n\n  const getInProgressCount = (): number => {\n    return getInProgressSessions().length;\n  };\n\n  const trackOperation = (\n    sessionId: string,\n    operation: Omit<DatabaseOperation, \"id\" | \"timestamp\">,\n  ): DatabaseOperation => {\n    const session = sessions.get(sessionId);\n\n    if (!session) {\n      throw new Error(`Session ${sessionId} not found`);\n    }\n\n    if (session.state !== \"in-progress\") {\n      throw new Error(\n        `Cannot track operation for session ${sessionId}: session is ${session.state}, expected in-progress`,\n      );\n    }\n\n    const trackedOperation: DatabaseOperation = {\n      ...operation,\n      id: `${sessionId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      timestamp: new Date(),\n    };\n\n    session.operations.push(trackedOperation);\n    return trackedOperation;\n  };\n\n  const getSessionOperations = (sessionId: string): DatabaseOperation[] => {\n    const session = sessions.get(sessionId);\n\n    if (!session) {\n      throw new Error(`Session ${sessionId} not found`);\n    }\n\n    return [...session.operations];\n  };\n\n  const getSessionOperationsByType = (\n    sessionId: string,\n    type: DatabaseOperationType,\n  ): DatabaseOperation[] => {\n    const operations = getSessionOperations(sessionId);\n    return operations.filter((op) => op.type === type);\n  };\n\n  const getSessionOperationsByCollection = (\n    sessionId: string,\n    collection: string,\n  ): DatabaseOperation[] => {\n    const operations = getSessionOperations(sessionId);\n    return operations.filter((op) => op.collection === collection);\n  };\n\n  const clearSessionOperations = (sessionId: string): boolean => {\n    const session = sessions.get(sessionId);\n\n    if (!session) {\n      return false;\n    }\n\n    session.operations = [];\n    return true;\n  };\n\n  return {\n    createSession,\n    getSession,\n    hasSession,\n    startSession,\n    resolveSession,\n    rejectSession,\n    deleteSession,\n    getIdleSessions,\n    getInProgressSessions,\n    getAllSessions,\n    clearAll,\n    getIdleCount,\n    getInProgressCount,\n    trackOperation,\n    getSessionOperations,\n    getSessionOperationsByType,\n    getSessionOperationsByCollection,\n    clearSessionOperations,\n  };\n}\n","/**\n * @fileoverview Logging Utilities for Payload Convex Adapter\n *\n * This module provides logging utilities for the adapter. It includes:\n * - A service logger factory that prefixes messages with the adapter name and prefix\n * - A generic logger factory for structured logging with multiple output methods\n *\n * ## Usage\n * ```typescript\n * const serviceLogger = createServiceLogger({ prefix: 'my_app' });\n * serviceLogger('Operation completed').log();\n *\n * const log = logger({ message: 'Hello' });\n * log.info();\n * ```\n *\n * @module tools/logger\n */\n\n/**\n * Props for creating a service logger.\n */\nexport type CreateServiceLoggerProps = {\n  /** The prefix to include in log messages (usually the adapter's table prefix) */\n  prefix: string;\n};\n\n/**\n * Return type for the service logger function.\n * Creates a logger with the adapter name and prefix prepended to messages.\n */\nexport type ServiceLogger = (message: string) => Logger;\n\n/**\n * Creates a service logger instance with a configured prefix.\n *\n * The service logger prepends \"PayloadConvexAdapter: {prefix} --\" to all messages,\n * making it easy to identify adapter-related logs in the console.\n *\n * @param {CreateServiceLoggerProps} props - Configuration options\n * @returns {ServiceLogger} A function that creates loggers with the configured prefix\n *\n * @example\n * ```typescript\n * const serviceLogger = createServiceLogger({ prefix: 'my_app' });\n *\n * // Log an info message\n * serviceLogger('Document created successfully').info();\n *\n * // Log an error\n * serviceLogger('Failed to connect').error();\n *\n * // Output: \"PayloadConvexAdapter: my_app -- Document created successfully\"\n * ```\n */\nexport function createServiceLogger(\n  props: CreateServiceLoggerProps\n): ServiceLogger {\n  const { prefix } = props;\n\n  const serviceLogger = (message: string): Logger => {\n    const log = logger({\n      message: `PayloadConvexAdapter: ${prefix} -- ${message}`,\n    });\n    return log;\n  };\n\n  return serviceLogger;\n}\n\n/**\n * Props for creating a logger instance.\n */\nexport type LoggerProps = {\n  /** The message to log */\n  message: string;\n};\n\n/**\n * Logger interface providing various console output methods.\n *\n * Each method outputs the message using the corresponding console function.\n */\nexport type Logger = {\n  /**\n   * Logs the message using console.log\n   * @returns {void}\n   */\n  log: () => void;\n\n  /**\n   * Logs the message as an error using console.error\n   * @returns {void}\n   */\n  error: () => void;\n\n  /**\n   * Logs the message as a warning using console.warn\n   * @returns {void}\n   */\n  warn: () => void;\n\n  /**\n   * Logs the message as info using console.info\n   * @returns {void}\n   */\n  info: () => void;\n\n  /**\n   * Logs the message as debug using console.debug\n   * @returns {void}\n   */\n  debug: () => void;\n\n  /**\n   * Logs the message with stack trace using console.trace\n   * @returns {void}\n   */\n  trace: () => void;\n\n  /**\n   * Logs the message using console.dir for object inspection\n   * @returns {void}\n   */\n  dir: () => void;\n\n  /**\n   * Logs the message as a table using console.table\n   * @returns {void}\n   */\n  table: () => void;\n\n  /**\n   * Starts a new console group with the message as label\n   * @returns {void}\n   */\n  group: () => void;\n\n  /**\n   * Ends the current console group\n   * @returns {void}\n   */\n  groupEnd: () => void;\n};\n\n/**\n * Creates a logger instance with various output methods.\n *\n * This factory function creates a logger object that provides\n * different console methods for outputting messages.\n *\n * @param {LoggerProps} props - The logger configuration\n * @returns {Logger} A logger object with various output methods\n *\n * @example\n * ```typescript\n * const log = logger({ message: 'Hello World' });\n *\n * // Standard log\n * log.log();\n *\n * // Warning\n * log.warn();\n *\n * // Error\n * log.error();\n *\n * // Group logs together\n * log.group();\n * log.log();\n * log.groupEnd();\n * ```\n */\nexport function logger(props: LoggerProps): Logger {\n  return {\n    log: () => console.log(props.message),\n    error: () => console.error(props.message),\n    warn: () => console.warn(props.message),\n    info: () => console.info(props.message),\n    debug: () => console.debug(props.message),\n    trace: () => console.trace(props.message),\n    dir: () => console.dir(props.message),\n    table: () => console.table(props.message),\n    group: () => console.group(props.message),\n    groupEnd: () => console.groupEnd(),\n  };\n}\n","/**\n * @fileoverview Payload Database Bindings\n *\n * This module exports all Payload database operation bindings organized by category.\n * Each binding implements a specific Payload database operation using the Convex\n * adapter's query and mutation system.\n *\n * ## Binding Categories\n *\n * - **transactions**: Transaction lifecycle management (begin, commit, rollback)\n * - **counts**: Document counting operations\n * - **creates**: Document creation operations\n * - **finds**: Document retrieval operations\n * - **deletes**: Document deletion operations\n * - **updates**: Document update operations\n * - **upserts**: Insert-or-update operations\n * - **drafts**: Draft document queries\n * - **migrations**: Database migration operations\n *\n * ## Usage\n * These bindings are used internally by the adapter and should not be called\n * directly. Instead, use the Payload API or the adapter service.\n *\n * @module convex/bindings\n */\n\nimport { beginTransaction } from \"./transactions/beginTransaction\";\nimport { commitTransaction } from \"./transactions/commitTransaction\";\nimport { rollbackTransaction } from \"./transactions/rollbackTransaction\";\n\nimport { count, countVersions, countGlobalVersions } from \"./count\";\nimport {\n  create,\n  createGlobal,\n  createVersion,\n  createGlobalVersion,\n  createMigration,\n} from \"./create\";\nimport {\n  find,\n  findOne,\n  findDistinct,\n  findGlobal,\n  findVersions,\n  findGlobalVersions,\n} from \"./find\";\nimport { deleteOne, deleteMany, deleteVersions } from \"./delete\";\nimport {\n  updateOne,\n  updateMany,\n  updateGlobal,\n  updateVersion,\n  updateGlobalVersion,\n  updateJobs,\n} from \"./update\";\nimport { upsert } from \"./upsert\";\nimport { queryDrafts } from \"./drafts\";\nimport {\n  migrate,\n  migrateDown,\n  migrateFresh,\n  migrateRefresh,\n  migrateReset,\n  migrateStatus,\n} from \"./migrate\";\n\n/**\n * Transaction management bindings.\n * Handles transaction lifecycle: begin, commit, and rollback.\n */\nexport const transactions = {\n  beginTransaction,\n  commitTransaction,\n  rollbackTransaction,\n};\n\n/**\n * Document counting bindings.\n * Provides count operations for collections, versions, and global versions.\n */\nexport const counts = {\n  count,\n  countVersions,\n  countGlobalVersions,\n};\n\n/**\n * Document creation bindings.\n * Handles creating documents, globals, versions, and migrations.\n */\nexport const creates = {\n  create,\n  createGlobal,\n  createVersion,\n  createGlobalVersion,\n  createMigration,\n};\n\n/**\n * Document retrieval bindings.\n * Provides find operations with pagination, filtering, and version support.\n */\nexport const finds = {\n  find,\n  findOne,\n  findDistinct,\n  findGlobal,\n  findVersions,\n  findGlobalVersions,\n};\n\n/**\n * Document deletion bindings.\n * Handles single, bulk, and version deletions.\n */\nexport const deletes = {\n  deleteOne,\n  deleteMany,\n  deleteVersions,\n};\n\n/**\n * Document update bindings.\n * Provides update operations for documents, globals, versions, and jobs.\n */\nexport const updates = {\n  updateOne,\n  updateMany,\n  updateGlobal,\n  updateVersion,\n  updateGlobalVersion,\n  updateJobs,\n};\n\n/**\n * Upsert bindings.\n * Handles insert-or-update operations.\n */\nexport const upserts = {\n  upsert,\n};\n\n/**\n * Draft query bindings.\n * Provides querying for draft documents.\n */\nexport const drafts = {\n  queryDrafts,\n};\n\n/**\n * Migration bindings.\n * Handles database schema migrations.\n */\nexport const migrations = {\n  migrate,\n  migrateDown,\n  migrateFresh,\n  migrateRefresh,\n  migrateReset,\n  migrateStatus,\n};\n","/**\n * @fileoverview Begin Transaction Binding\n *\n * This module implements the beginTransaction operation for the Convex adapter.\n * It creates a new transaction session that can be used to group multiple\n * database operations together.\n *\n * ## Transaction Flow\n * 1. `beginTransaction` - Creates a new session (this module)\n * 2. Perform database operations\n * 3. `commitTransaction` - Commits all operations\n * 4. OR `rollbackTransaction` - Discards all operations\n *\n * @module convex/bindings/transactions/beginTransaction\n */\n\nimport { BeginTransaction } from \"payload\";\nimport type { AdapterService } from \"../../adapter/service\";\n\n/**\n * Props for the beginTransaction operation.\n */\nexport type ConvexAdapterBeginTransactionProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n};\n\n/**\n * Return type for the beginTransaction operation.\n * Matches Payload's BeginTransaction return type.\n */\nexport type ConvexAdapterBeginTransaction = ReturnType<\n  Awaited<BeginTransaction>\n>;\n\n/**\n * Begins a new database transaction.\n *\n * Creates a new transaction session with a unique ID. The session is tracked\n * by the session tracker and can be used to group database operations together.\n * The transaction must be either committed or rolled back to complete.\n *\n * @param {ConvexAdapterBeginTransactionProps} props - The operation parameters\n * @returns {Promise<string>} The unique transaction session ID\n *\n * @example\n * ```typescript\n * const transactionId = await beginTransaction({ service });\n * // Perform operations...\n * await commitTransaction({ service, incomingID: transactionId });\n * ```\n */\nexport async function beginTransaction(\n  props: ConvexAdapterBeginTransactionProps\n) {\n  const { service } = props;\n  const id = service.tools.createRandomID();\n  const session = service.tools.sessionTracker.createSession(id);\n  return session.id;\n}\n","/**\n * @fileoverview Commit Transaction Binding\n *\n * This module implements the commitTransaction operation for the Convex adapter.\n * It finalizes a transaction session, marking all operations as committed.\n *\n * ## Commit Behavior\n * - Resolves the session if it's in \"in-progress\" state\n * - Cleans up orphaned sessions (not in \"in-progress\" state)\n * - Removes the session from the tracker after commit\n *\n * @module convex/bindings/transactions/commitTransaction\n */\n\nimport type { CommitTransaction } from \"payload\";\nimport type { AdapterService } from \"../../adapter/service\";\n\n/**\n * Props for the commitTransaction operation.\n */\nexport type ConvexAdapterCommitTransactionProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The transaction ID to commit (may be a Promise) */\n  incomingID: Parameters<CommitTransaction>[0];\n};\n\n/**\n * Return type for the commitTransaction operation.\n */\nexport type ConvexAdapterCommitTransaction = ReturnType<\n  Awaited<CommitTransaction>\n>;\n\n/**\n * Commits a database transaction.\n *\n * Finalizes the transaction session, marking all tracked operations as\n * committed. The session is removed from the tracker after successful commit.\n *\n * If the session doesn't exist or is not in \"in-progress\" state, the function\n * performs cleanup and returns without error.\n *\n * @param {ConvexAdapterCommitTransactionProps} props - The operation parameters\n * @returns {Promise<void>} Resolves when the transaction is committed\n *\n * @example\n * ```typescript\n * const transactionId = await beginTransaction({ service });\n * // Perform operations...\n * await commitTransaction({ service, incomingID: transactionId });\n * ```\n */\nexport async function commitTransaction(\n  props: ConvexAdapterCommitTransactionProps,\n) {\n  const { service, incomingID } = props;\n\n  const transactionID =\n    incomingID instanceof Promise ? await incomingID : incomingID;\n  const transactionIdStr = transactionID.toString();\n\n  // Look up session\n  if (!service.tools.sessionTracker.hasSession(transactionIdStr)) {\n    return;\n  }\n\n  const session = service.tools.sessionTracker.getSession(transactionIdStr);\n\n  // If the session is not 'in-progress', treat as orphaned (& clean up)\n  if (session?.state !== \"in-progress\") {\n    service.tools.sessionTracker.deleteSession(transactionIdStr);\n    return;\n  }\n\n  // In a real DB, you'd commit the transaction here.\n  // In our convex adapter, resolving the session is \"committing\".\n  try {\n    service.tools.sessionTracker.resolveSession(transactionIdStr);\n  } catch (_) {\n    // best effort session cleanup: we're committed regardless\n  }\n\n  // Remove session to prevent race condition (adapter style)\n  service.tools.sessionTracker.deleteSession(transactionIdStr);\n}\n","/**\n * @fileoverview Rollback Transaction Binding\n *\n * This module implements the rollbackTransaction operation for the Convex adapter.\n * It cancels a transaction session, discarding all tracked operations.\n *\n * ## Rollback Behavior\n * - Rejects the session if it's in \"in-progress\" state\n * - Cleans up orphaned sessions (not in \"in-progress\" state)\n * - Removes the session from the tracker after rollback\n *\n * @module convex/bindings/transactions/rollbackTransaction\n */\n\nimport type { RollbackTransaction } from \"payload\";\nimport type { AdapterService } from \"../../adapter/service\";\n\n/**\n * Props for the rollbackTransaction operation.\n */\nexport type ConvexAdapterRollbackTransactionProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The transaction ID to rollback (may be a Promise) */\n  incomingID: Parameters<RollbackTransaction>[0];\n};\n\n/**\n * Return type for the rollbackTransaction operation.\n */\nexport type ConvexAdapterRollbackTransaction = ReturnType<\n  Awaited<RollbackTransaction>\n>;\n\n/**\n * Rolls back a database transaction.\n *\n * Cancels the transaction session, discarding all tracked operations.\n * The session is removed from the tracker after rollback.\n *\n * If the session doesn't exist or is not in \"in-progress\" state, the function\n * performs cleanup and returns without error.\n *\n * @param {ConvexAdapterRollbackTransactionProps} props - The operation parameters\n * @returns {Promise<void>} Resolves when the transaction is rolled back\n *\n * @example\n * ```typescript\n * const transactionId = await beginTransaction({ service });\n * try {\n *   // Perform operations...\n *   await commitTransaction({ service, incomingID: transactionId });\n * } catch (error) {\n *   await rollbackTransaction({ service, incomingID: transactionId });\n * }\n * ```\n */\nexport async function rollbackTransaction(\n  props: ConvexAdapterRollbackTransactionProps\n) {\n  const { service, incomingID } = props;\n\n  const transactionID =\n    incomingID instanceof Promise ? await incomingID : incomingID;\n  const transactionIdStr = transactionID.toString();\n\n  // Look up session\n  if (!service.tools.sessionTracker.hasSession(transactionIdStr)) {\n    return;\n  }\n\n  const session = service.tools.sessionTracker.getSession(transactionIdStr);\n\n  // If the session is not 'in-progress', treat as orphaned (& clean up)\n  if (session?.state !== \"in-progress\") {\n    service.tools.sessionTracker.deleteSession(transactionIdStr);\n    return;\n  }\n\n  try {\n    service.tools.sessionTracker.rejectSession(transactionIdStr);\n  } catch (_) {\n    // best effort session cleanup: we're rolled back regardless\n  }\n\n  // Remove session to prevent race condition (adapter style)\n  service.tools.sessionTracker.deleteSession(transactionIdStr);\n}\n","/**\n * @fileoverview Count Operation Bindings\n *\n * This module implements Payload's count operations for the Convex adapter.\n * It provides document counting with optional where clause filtering for:\n * - Regular collections\n * - Version collections\n * - Global version collections\n *\n * @module convex/bindings/count\n */\n\nimport type { AdapterService } from \"../adapter/service\";\nimport { Count, CountVersions, CountGlobalVersions } from \"payload\";\n\n/**\n * Props for the count operation.\n */\nexport type AdapaterCountProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming count parameters from Payload */\n  incomingCount: Parameters<Count>[0];\n};\n\n/**\n * Props for the countVersions operation.\n */\nexport type AdapaterCountVersionsProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming countVersions parameters from Payload */\n  incomingCountVersions: Parameters<CountVersions>[0];\n};\n\n/**\n * Props for the countGlobalVersions operation.\n */\nexport type AdapaterCountGlobalVersionsProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming countGlobalVersions parameters from Payload */\n  incomingCountGlobalVersions: Parameters<CountGlobalVersions>[0];\n};\n\n/**\n * Counts documents in a collection matching the where clause.\n *\n * @param {AdapaterCountProps} props - The count operation parameters\n * @returns {Promise<{ totalDocs: number }>} The count result\n */\nexport async function count(props: AdapaterCountProps) {\n  const { service, incomingCount } = props;\n\n  // Pass all incoming params to queryProcessor\n  const processedQuery = service.tools.queryProcessor({\n    service,\n    ...incomingCount,\n    convex: false,\n  });\n\n  const totalDocs = await service.db.query({}).collectionCountQuery.adapter({\n    service,\n    ...processedQuery.convexQueryProps,\n  });\n\n  return {\n    totalDocs,\n  } satisfies Awaited<ReturnType<Count>>;\n}\n\n/**\n * Counts version documents for a collection.\n *\n * Versions are stored in collections named `{collection}_versions`.\n *\n * @param {AdapaterCountVersionsProps} props - The countVersions operation parameters\n * @returns {Promise<{ totalDocs: number }>} The count result\n */\nexport async function countVersions(props: AdapaterCountVersionsProps) {\n  const { service, incomingCountVersions } = props;\n  const { collection } = incomingCountVersions;\n\n  // Versions are stored in a collection with \"_versions\" suffix\n  const versionsCollection = `${collection}_versions`;\n\n  // Pass all incoming params to queryProcessor\n  const processedQuery = service.tools.queryProcessor({\n    service,\n    ...incomingCountVersions,\n    collection: versionsCollection,\n    convex: false,\n  });\n\n  const totalDocs = await service.db.query({}).collectionCountQuery.adapter({\n    service,\n    ...processedQuery.convexQueryProps,\n  });\n\n  return {\n    totalDocs,\n  } satisfies Awaited<ReturnType<CountVersions>>;\n}\n\n/**\n * Counts version documents for a global.\n *\n * Global versions are stored in collections named `{global}_global_versions`.\n *\n * @param {AdapaterCountGlobalVersionsProps} props - The countGlobalVersions operation parameters\n * @returns {Promise<{ totalDocs: number }>} The count result\n */\nexport async function countGlobalVersions(\n  props: AdapaterCountGlobalVersionsProps\n) {\n  const { service, incomingCountGlobalVersions } = props;\n  const { global } = incomingCountGlobalVersions;\n\n  // Global versions are stored in a collection with \"_global_versions\" suffix\n  const globalVersionsCollection = `${global}_global_versions`;\n\n  // Pass all incoming params to queryProcessor\n  const processedQuery = service.tools.queryProcessor({\n    service,\n    ...incomingCountGlobalVersions,\n    collection: globalVersionsCollection,\n    convex: false,\n  });\n\n  const totalDocs = await service.db.query({}).collectionCountQuery.adapter({\n    service,\n    ...processedQuery.convexQueryProps,\n  });\n\n  return {\n    totalDocs,\n  } satisfies Awaited<ReturnType<CountGlobalVersions>>;\n}\n","/**\n * @fileoverview Create Operation Bindings\n *\n * This module implements Payload's create operations for the Convex adapter.\n * It provides document creation for:\n * - Regular documents\n * - Global documents\n * - Document versions\n * - Global versions\n * - Migration records\n *\n * @module convex/bindings/create\n * @todo Implement all create operations\n */\n\nimport type { AdapterService } from \"../adapter/service\";\nimport {\n  Create,\n  CreateGlobal,\n  CreateVersion,\n  CreateGlobalVersion,\n  CreateMigration,\n} from \"payload\";\n\n/**\n * Props for the create operation.\n */\nexport type AdapterCreateProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming create parameters from Payload */\n  incomingCreate: Parameters<Create>[0];\n};\n\n/**\n * Props for the createGlobal operation.\n */\nexport type AdapterCreateGlobalProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming createGlobal parameters from Payload */\n  incomingCreateGlobal: Parameters<CreateGlobal>[0];\n};\n\n/**\n * Props for the createVersion operation.\n */\nexport type AdapterCreateVersionProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming createVersion parameters from Payload */\n  incomingCreateVersion: Parameters<CreateVersion>[0];\n};\n\n/**\n * Props for the createGlobalVersion operation.\n */\nexport type AdapterCreateGlobalVersionProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming createGlobalVersion parameters from Payload */\n  incomingCreateGlobalVersion: Parameters<CreateGlobalVersion>[0];\n};\n\n/**\n * Props for the createMigration operation.\n */\nexport type AdapterCreateMigrationProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming createMigration parameters from Payload */\n  incomingCreateMigration: Parameters<CreateMigration>[0];\n};\n\n/**\n * Creates a new document in a collection.\n *\n * @param {AdapterCreateProps} props - The create operation parameters\n * @returns {Promise<Awaited<ReturnType<Create>>>} The created document\n *\n * @example\n * ```typescript\n * const newDoc = await create({\n *   service,\n *   incomingCreate: {\n *     collection: 'posts',\n *     data: { title: 'Hello World', status: 'draft' },\n *   },\n * });\n * ```\n */\nexport async function create(props: AdapterCreateProps) {\n  const { service, incomingCreate } = props;\n  const { collection, data, draft, returning = true } = incomingCreate;\n\n  // Prepare document data with draft status if applicable\n  const documentData = draft ? { ...data, _status: \"draft\" } : data;\n\n  // Insert the document\n  const docId = await service.db.mutation({}).insert.adapter({\n    service,\n    collection,\n    data: documentData,\n  });\n\n  // Only fetch if returning is true (default)\n  if (!returning) {\n    return { id: docId } as Awaited<ReturnType<Create>>;\n  }\n\n  // Fetch the created document\n  const doc = await service.db.query({}).getById.adapter({\n    service,\n    collection,\n    id: docId as string,\n  });\n\n  // Process result through queryProcessor for format conversion and post-filters\n  const processedQuery = service.tools.queryProcessor({\n    service,\n    ...incomingCreate,\n    convex: false,\n  });\n\n  return processedQuery.processResult(doc) as Awaited<ReturnType<Create>>;\n}\n\n/**\n * Creates a new global document.\n *\n * Globals are singleton documents stored in collections named `_globals_{slug}`.\n *\n * @param {AdapterCreateGlobalProps} props - The createGlobal operation parameters\n * @returns {Promise<Awaited<ReturnType<CreateGlobal>>>} The created global document\n *\n * @example\n * ```typescript\n * const global = await createGlobal({\n *   service,\n *   incomingCreateGlobal: {\n *     slug: 'settings',\n *     data: { siteName: 'My Site', theme: 'dark' },\n *   },\n * });\n * ```\n */\nexport async function createGlobal(props: AdapterCreateGlobalProps) {\n  const { service, incomingCreateGlobal } = props;\n  const { slug, data, returning = true } = incomingCreateGlobal;\n\n  // Globals are stored in a collection named after the slug\n  const globalCollection = `_globals_${slug}`;\n\n  // Insert the global document\n  const docId = await service.db.mutation({}).insert.adapter({\n    service,\n    collection: globalCollection,\n    data,\n  });\n\n  // Only fetch if returning is true (default)\n  if (!returning) {\n    return { id: docId } as Awaited<ReturnType<CreateGlobal>>;\n  }\n\n  // Fetch the created global\n  const doc = await service.db.query({}).getById.adapter({\n    service,\n    collection: globalCollection,\n    id: docId as string,\n  });\n\n  // Process result through queryProcessor for format conversion and post-filters\n  const processedQuery = service.tools.queryProcessor({\n    service,\n    ...incomingCreateGlobal,\n    collection: globalCollection,\n    convex: false,\n  });\n\n  return processedQuery.processResult(doc) as Awaited<ReturnType<CreateGlobal>>;\n}\n\n/**\n * Creates a new version of a document.\n *\n * Versions are stored in collections named `{collection}_versions`.\n *\n * @param {AdapterCreateVersionProps} props - The createVersion operation parameters\n * @returns {Promise<Awaited<ReturnType<CreateVersion>>>} The created version document\n *\n * @example\n * ```typescript\n * const version = await createVersion({\n *   service,\n *   incomingCreateVersion: {\n *     collectionSlug: 'posts',\n *     parent: '123',\n *     versionData: { title: 'Updated Title' },\n *     autosave: false,\n *     createdAt: new Date().toISOString(),\n *     updatedAt: new Date().toISOString(),\n *   },\n * });\n * ```\n */\nexport async function createVersion(props: AdapterCreateVersionProps) {\n  const { service, incomingCreateVersion } = props;\n  const {\n    collectionSlug,\n    parent,\n    versionData,\n    autosave,\n    createdAt,\n    updatedAt,\n    publishedLocale,\n    returning = true,\n    snapshot,\n  } = incomingCreateVersion;\n\n  // Versions are stored in a collection with \"_versions\" suffix\n  const versionsCollection = `${collectionSlug}_versions`;\n\n  // Prepare version document with optional snapshot\n  const versionDoc: Record<string, unknown> = {\n    parent,\n    version: versionData,\n    autosave,\n    createdAt,\n    updatedAt,\n    publishedLocale,\n    latest: true, // Mark as latest version\n  };\n\n  // Include snapshot if provided\n  if (snapshot !== undefined) {\n    versionDoc.snapshot = snapshot;\n  }\n\n  // Insert the version document\n  const docId = await service.db.mutation({}).insert.adapter({\n    service,\n    collection: versionsCollection,\n    data: versionDoc,\n  });\n\n  // Only fetch if returning is true (default)\n  if (!returning) {\n    return { id: docId } as Awaited<ReturnType<CreateVersion>>;\n  }\n\n  // Fetch the created version\n  const doc = await service.db.query({}).getById.adapter({\n    service,\n    collection: versionsCollection,\n    id: docId as string,\n  });\n\n  // Process result through queryProcessor for format conversion and post-filters\n  const processedQuery = service.tools.queryProcessor({\n    service,\n    ...incomingCreateVersion,\n    collection: versionsCollection,\n    locale: publishedLocale,\n    convex: false,\n  });\n\n  return processedQuery.processResult(doc) as Awaited<\n    ReturnType<CreateVersion>\n  >;\n}\n\n/**\n * Creates a new version of a global document.\n *\n * Global versions are stored in collections named `{global}_global_versions`.\n *\n * @param {AdapterCreateGlobalVersionProps} props - The createGlobalVersion operation parameters\n * @returns {Promise<Awaited<ReturnType<CreateGlobalVersion>>>} The created global version document\n *\n * @example\n * ```typescript\n * const globalVersion = await createGlobalVersion({\n *   service,\n *   incomingCreateGlobalVersion: {\n *     globalSlug: 'settings',\n *     versionData: { siteName: 'Updated Site Name' },\n *     autosave: false,\n *     createdAt: new Date().toISOString(),\n *     updatedAt: new Date().toISOString(),\n *   },\n * });\n * ```\n */\nexport async function createGlobalVersion(\n  props: AdapterCreateGlobalVersionProps\n) {\n  const { service, incomingCreateGlobalVersion } = props;\n  const {\n    globalSlug,\n    versionData,\n    autosave,\n    createdAt,\n    updatedAt,\n    publishedLocale,\n    returning = true,\n    snapshot,\n  } = incomingCreateGlobalVersion;\n\n  // Global versions are stored in a collection with \"_global_versions\" suffix\n  const globalVersionsCollection = `${globalSlug}_global_versions`;\n\n  // Prepare global version document (note: no parent field for globals)\n  const versionDoc: Record<string, unknown> = {\n    version: versionData,\n    autosave,\n    createdAt,\n    updatedAt,\n    publishedLocale,\n    latest: true, // Mark as latest version\n  };\n\n  // Include snapshot if provided\n  if (snapshot !== undefined) {\n    versionDoc.snapshot = snapshot;\n  }\n\n  // Insert the global version document\n  const docId = await service.db.mutation({}).insert.adapter({\n    service,\n    collection: globalVersionsCollection,\n    data: versionDoc,\n  });\n\n  // Only fetch if returning is true (default)\n  if (!returning) {\n    return { id: docId } as Awaited<ReturnType<CreateGlobalVersion>>;\n  }\n\n  // Fetch the created global version\n  const doc = await service.db.query({}).getById.adapter({\n    service,\n    collection: globalVersionsCollection,\n    id: docId as string,\n  });\n\n  // Process result through queryProcessor for format conversion and post-filters\n  const processedQuery = service.tools.queryProcessor({\n    service,\n    ...incomingCreateGlobalVersion,\n    collection: globalVersionsCollection,\n    locale: publishedLocale,\n    convex: false,\n  });\n\n  return processedQuery.processResult(doc) as Awaited<\n    ReturnType<CreateGlobalVersion>\n  >;\n}\n\n/**\n * Creates a new migration record.\n *\n * Migration records track which migrations have been run on the database.\n * This is a placeholder implementation that logs the migration creation.\n *\n * @param {AdapterCreateMigrationProps} props - The createMigration operation parameters\n * @returns {Promise<void>}\n *\n * @note This is a placeholder implementation. Full migration support requires\n * additional infrastructure for tracking and executing migrations.\n */\nexport async function createMigration(props: AdapterCreateMigrationProps) {\n  const { service, incomingCreateMigration } = props;\n\n  service.system\n    .logger(\n      JSON.stringify(\n        {\n          binding: \"createMigration\",\n          params: incomingCreateMigration,\n        },\n        null,\n        2\n      )\n    )\n    .dir();\n\n  // Placeholder: Migration creation would typically write to a migrations table\n  // For now, we just log the request\n  console.log(\"Migration creation requested:\", incomingCreateMigration);\n}\n","/**\n * @fileoverview Find Operation Bindings\n *\n * This module implements Payload's find operations for the Convex adapter.\n * It provides document retrieval with support for:\n * - Pagination (page-based with configurable limits)\n * - Filtering (via ParsedWhereFilter)\n * - Sorting (ascending/descending)\n * - Distinct value queries\n * - Version and global document retrieval\n *\n * ## Collection Naming Conventions\n * - Regular collections: `{collection}`\n * - Version collections: `{collection}_versions`\n * - Global collections: `_globals_{slug}`\n * - Global version collections: `{global}_global_versions`\n *\n * @module convex/bindings/find\n */\n\nimport type { AdapterService } from \"../adapter/service\";\nimport {\n  Find,\n  FindOne,\n  FindDistinct,\n  FindGlobal,\n  FindVersions,\n  FindGlobalVersions,\n} from \"payload\";\n\n/**\n * Props for the find operation.\n */\nexport type AdapterFindProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming find parameters from Payload */\n  incomingFind: Parameters<Find>[0];\n};\n\n/**\n * Props for the findOne operation.\n */\nexport type AdapterFindOneProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming findOne parameters from Payload */\n  incomingFindOne: Parameters<FindOne>[0];\n};\n\n/**\n * Props for the findDistinct operation.\n */\nexport type AdapterFindDistinctProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming findDistinct parameters from Payload */\n  incomingFindDistinct: Parameters<FindDistinct>[0];\n};\n\n/**\n * Props for the findGlobal operation.\n */\nexport type AdapterFindGlobalProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming findGlobal parameters from Payload */\n  incomingFindGlobal: Parameters<FindGlobal>[0];\n};\n\n/**\n * Props for the findVersions operation.\n */\nexport type AdapterFindVersionsProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming findVersions parameters from Payload */\n  incomingFindVersions: Parameters<FindVersions>[0];\n};\n\n/**\n * Props for the findGlobalVersions operation.\n */\nexport type AdapterFindGlobalVersionsProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming findGlobalVersions parameters from Payload */\n  incomingFindGlobalVersions: Parameters<FindGlobalVersions>[0];\n};\n\n/**\n * Finds documents in a collection with pagination, filtering, and sorting.\n *\n * This function implements Payload's Find operation, supporting:\n * - Page-based pagination with configurable page size\n * - Where clause filtering via ParsedWhereFilter\n * - Sort order (ascending/descending based on sort string prefix)\n * - Option to disable pagination and fetch all documents\n *\n * @param {AdapterFindProps} props - The find operation parameters\n * @returns {Promise<Awaited<ReturnType<Find>>>} Paginated result with docs and metadata\n *\n * @example\n * ```typescript\n * const result = await find({\n *   service,\n *   incomingFind: {\n *     collection: 'posts',\n *     where: { status: { equals: 'published' } },\n *     limit: 10,\n *     page: 1,\n *     sort: '-createdAt',\n *   },\n * });\n * ```\n */\nexport async function find(props: AdapterFindProps) {\n  const { service, incomingFind } = props;\n  const {\n    collection,\n    limit = 10,\n    page = 1,\n    pagination = true,\n    skip,\n  } = incomingFind;\n\n  // Use skip if provided (deprecated but still supported)\n  const effectivePage =\n    skip !== undefined ? Math.floor(skip / limit) + 1 : page;\n\n  // Pass all incoming params to queryProcessor\n  const processedQuery = service.tools.queryProcessor({\n    service,\n    ...incomingFind,\n    page: effectivePage,\n    convex: false,\n  });\n\n  // If pagination is disabled (limit = 0), fetch all documents\n  if (!pagination || limit === 0) {\n    const rawDocs = await service.db.query({}).collectionWhereQuery.adapter({\n      service,\n      ...processedQuery.convexQueryProps,\n    });\n\n    const docs = processedQuery.processResult(rawDocs);\n\n    return {\n      docs,\n      totalDocs: docs.length,\n      limit: docs.length,\n      page: 1,\n      totalPages: 1,\n      hasNextPage: false,\n      hasPrevPage: false,\n      pagingCounter: 1,\n    } as Awaited<ReturnType<Find>>;\n  }\n\n  // Get total count for pagination calculations\n  const totalDocs = await service.db.query({}).collectionCountQuery.adapter({\n    service,\n    ...processedQuery.convexQueryProps,\n  });\n\n  const totalPages = Math.ceil(totalDocs / limit);\n  const hasNextPage = page < totalPages;\n  const hasPrevPage = page > 1;\n  const pagingCounter = (page - 1) * limit + 1;\n\n  // Fetch all matching documents with order, then slice for pagination\n  // TODO: Optimize with cursor-based pagination when available\n  const allDocs = await service.db.query({}).collectionWhereOrderQuery.adapter({\n    service,\n    ...processedQuery.convexQueryProps,\n    order: processedQuery.convexQueryProps.order ?? \"desc\",\n  });\n\n  const skipAmount = skip !== undefined ? skip : (effectivePage - 1) * limit;\n  const rawDocs = allDocs.slice(skipAmount, skipAmount + limit);\n  const docs = processedQuery.processResult(rawDocs);\n\n  return {\n    docs,\n    totalDocs,\n    limit,\n    page: effectivePage,\n    totalPages,\n    hasNextPage,\n    hasPrevPage,\n    pagingCounter,\n    nextPage: hasNextPage ? effectivePage + 1 : null,\n    prevPage: hasPrevPage ? effectivePage - 1 : null,\n  } as Awaited<ReturnType<Find>>;\n}\n\n/**\n * Finds a single document matching the where clause.\n *\n * @param {AdapterFindOneProps} props - The findOne operation parameters\n * @returns {Promise<Awaited<ReturnType<FindOne>>>} The found document or null\n */\nexport async function findOne(props: AdapterFindOneProps) {\n  const { service, incomingFindOne } = props;\n\n  // Pass all incoming params to queryProcessor\n  const processedQuery = service.tools.queryProcessor({\n    service,\n    ...incomingFindOne,\n    limit: 1,\n    convex: false,\n  });\n\n  // Fetch with limit 1\n  const docs = await service.db.query({}).collectionWhereLimitQuery.adapter({\n    service,\n    ...processedQuery.convexQueryProps,\n    limit: processedQuery.convexQueryProps.limit!,\n  });\n\n  if (!docs || docs.length === 0) {\n    return null as Awaited<ReturnType<FindOne>>;\n  }\n\n  return processedQuery.processResult(docs[0]) as Awaited<ReturnType<FindOne>>;\n}\n\n/**\n * Finds distinct values for a specific field across documents.\n *\n * This function retrieves unique values for the specified field from\n * documents matching the where clause, with pagination support.\n *\n * @param {AdapterFindDistinctProps} props - The findDistinct operation parameters\n * @returns {Promise<Awaited<ReturnType<FindDistinct>>>} Paginated distinct values\n */\nexport async function findDistinct(props: AdapterFindDistinctProps) {\n  const { service, incomingFindDistinct } = props;\n  const { field, limit = 10, page = 1 } = incomingFindDistinct;\n\n  // Pass all incoming params to queryProcessor\n  const processedQuery = service.tools.queryProcessor({\n    service,\n    ...incomingFindDistinct,\n    convex: false,\n  });\n\n  // Fetch all matching documents\n  const allDocs = await service.db.query({}).collectionWhereOrderQuery.adapter({\n    service,\n    ...processedQuery.convexQueryProps,\n    order: processedQuery.convexQueryProps.order ?? \"desc\",\n  });\n\n  // Transform documents to Payload format for field extraction\n  const processedDocs = processedQuery.processResult(allDocs);\n\n  // Extract distinct values for the specified field\n  const valueSet = new Set<any>();\n  for (const doc of processedDocs) {\n    const value = (doc as Record<string, any>)[field];\n    if (value !== undefined && value !== null) {\n      valueSet.add(value);\n    }\n  }\n\n  const allValues = Array.from(valueSet);\n  const totalDocs = allValues.length;\n  const totalPages = Math.ceil(totalDocs / limit);\n  const hasNextPage = page < totalPages;\n  const hasPrevPage = page > 1;\n  const pagingCounter = (page - 1) * limit + 1;\n\n  // Paginate the distinct values\n  const skip = (page - 1) * limit;\n  const values = allValues.slice(skip, skip + limit);\n\n  return {\n    values: values.map((v) => ({ [field]: v })),\n    totalDocs,\n    limit,\n    page,\n    totalPages,\n    hasNextPage,\n    hasPrevPage,\n    pagingCounter,\n    nextPage: hasNextPage ? page + 1 : null,\n    prevPage: hasPrevPage ? page - 1 : null,\n  } as Awaited<ReturnType<FindDistinct>>;\n}\n\n/**\n * Finds a global document by its slug.\n *\n * Globals are singleton documents stored in collections named `_globals_{slug}`.\n *\n * @param {AdapterFindGlobalProps} props - The findGlobal operation parameters\n * @returns {Promise<Awaited<ReturnType<FindGlobal>>>} The global document or empty object\n */\nexport async function findGlobal(props: AdapterFindGlobalProps) {\n  const { service, incomingFindGlobal } = props;\n  const { slug } = incomingFindGlobal;\n\n  // Globals are stored in a collection named after the slug\n  const globalCollection = `_globals_${slug}`;\n\n  // Pass all incoming params to queryProcessor\n  const processedQuery = service.tools.queryProcessor({\n    service,\n    ...incomingFindGlobal,\n    collection: globalCollection,\n    limit: 1,\n    convex: false,\n  });\n\n  // Fetch with limit 1 since globals are single documents\n  const docs = await service.db.query({}).collectionWhereLimitQuery.adapter({\n    service,\n    ...processedQuery.convexQueryProps,\n    limit: processedQuery.convexQueryProps.limit!,\n  });\n\n  if (!docs || docs.length === 0) {\n    return {} as Awaited<ReturnType<FindGlobal>>;\n  }\n\n  return processedQuery.processResult(docs[0]) as Awaited<\n    ReturnType<FindGlobal>\n  >;\n}\n\n/**\n * Finds version documents for a collection.\n *\n * Versions are stored in collections named `{collection}_versions`.\n *\n * @param {AdapterFindVersionsProps} props - The findVersions operation parameters\n * @returns {Promise<Awaited<ReturnType<FindVersions>>>} Paginated version documents\n */\nexport async function findVersions(props: AdapterFindVersionsProps) {\n  const { service, incomingFindVersions } = props;\n  const {\n    collection,\n    limit = 10,\n    page = 1,\n    pagination = true,\n    skip,\n  } = incomingFindVersions;\n\n  // Use skip if provided (deprecated but still supported)\n  const effectivePage =\n    skip !== undefined ? Math.floor(skip / limit) + 1 : page;\n\n  // Versions are stored in a collection with \"_versions\" suffix\n  const versionsCollection = `${collection}_versions`;\n\n  // Pass all incoming params to queryProcessor\n  const processedQuery = service.tools.queryProcessor({\n    service,\n    ...incomingFindVersions,\n    collection: versionsCollection,\n    page: effectivePage,\n    convex: false,\n  });\n\n  // If pagination is disabled (limit = 0), fetch all documents\n  if (!pagination || limit === 0) {\n    const rawDocs = await service.db.query({}).collectionWhereQuery.adapter({\n      service,\n      ...processedQuery.convexQueryProps,\n    });\n\n    const docs = processedQuery.processResult(rawDocs);\n\n    return {\n      docs,\n      totalDocs: docs.length,\n      limit: docs.length,\n      page: 1,\n      totalPages: 1,\n      hasNextPage: false,\n      hasPrevPage: false,\n      pagingCounter: 1,\n    } as Awaited<ReturnType<FindVersions>>;\n  }\n\n  // Get total count for pagination calculations\n  const totalDocs = await service.db.query({}).collectionCountQuery.adapter({\n    service,\n    ...processedQuery.convexQueryProps,\n  });\n\n  const totalPages = Math.ceil(totalDocs / limit);\n  const hasNextPage = page < totalPages;\n  const hasPrevPage = page > 1;\n  const pagingCounter = (page - 1) * limit + 1;\n\n  // Fetch all matching documents with order, then slice for pagination\n  const skipAmount = skip !== undefined ? skip : (effectivePage - 1) * limit;\n\n  const allDocs = await service.db.query({}).collectionWhereOrderQuery.adapter({\n    service,\n    ...processedQuery.convexQueryProps,\n    order: processedQuery.convexQueryProps.order ?? \"desc\",\n  });\n\n  const rawDocs = allDocs.slice(skipAmount, skipAmount + limit);\n  const docs = processedQuery.processResult(rawDocs);\n\n  return {\n    docs,\n    totalDocs,\n    limit,\n    page: effectivePage,\n    totalPages,\n    hasNextPage,\n    hasPrevPage,\n    pagingCounter,\n    nextPage: hasNextPage ? effectivePage + 1 : null,\n    prevPage: hasPrevPage ? effectivePage - 1 : null,\n  } as Awaited<ReturnType<FindVersions>>;\n}\n\n/**\n * Finds version documents for a global.\n *\n * Global versions are stored in collections named `{global}_global_versions`.\n *\n * @param {AdapterFindGlobalVersionsProps} props - The findGlobalVersions operation parameters\n * @returns {Promise<Awaited<ReturnType<FindGlobalVersions>>>} Paginated global version documents\n */\nexport async function findGlobalVersions(\n  props: AdapterFindGlobalVersionsProps\n) {\n  const { service, incomingFindGlobalVersions } = props;\n  const {\n    global,\n    limit = 10,\n    page = 1,\n    pagination = true,\n    skip,\n  } = incomingFindGlobalVersions;\n\n  // Use skip if provided (deprecated but still supported)\n  const effectivePage =\n    skip !== undefined ? Math.floor(skip / limit) + 1 : page;\n\n  // Global versions are stored in a collection with \"_global_versions\" suffix\n  const globalVersionsCollection = `${global}_global_versions`;\n\n  // Pass all incoming params to queryProcessor\n  const processedQuery = service.tools.queryProcessor({\n    service,\n    ...incomingFindGlobalVersions,\n    collection: globalVersionsCollection,\n    page: effectivePage,\n    convex: false,\n  });\n\n  // If pagination is disabled (limit = 0), fetch all documents\n  if (!pagination || limit === 0) {\n    const rawDocs = await service.db.query({}).collectionWhereQuery.adapter({\n      service,\n      ...processedQuery.convexQueryProps,\n    });\n\n    const docs = processedQuery.processResult(rawDocs);\n\n    return {\n      docs,\n      totalDocs: docs.length,\n      limit: docs.length,\n      page: 1,\n      totalPages: 1,\n      hasNextPage: false,\n      hasPrevPage: false,\n      pagingCounter: 1,\n    } as Awaited<ReturnType<FindGlobalVersions>>;\n  }\n\n  // Get total count for pagination calculations\n  const totalDocs = await service.db.query({}).collectionCountQuery.adapter({\n    service,\n    ...processedQuery.convexQueryProps,\n  });\n\n  const totalPages = Math.ceil(totalDocs / limit);\n  const hasNextPage = page < totalPages;\n  const hasPrevPage = page > 1;\n  const pagingCounter = (page - 1) * limit + 1;\n\n  // Fetch all matching documents with order, then slice for pagination\n  const skipAmount = skip !== undefined ? skip : (effectivePage - 1) * limit;\n\n  const allDocs = await service.db.query({}).collectionWhereOrderQuery.adapter({\n    service,\n    ...processedQuery.convexQueryProps,\n    order: processedQuery.convexQueryProps.order ?? \"desc\",\n  });\n\n  const rawDocs = allDocs.slice(skipAmount, skipAmount + limit);\n  const docs = processedQuery.processResult(rawDocs);\n\n  return {\n    docs,\n    totalDocs,\n    limit,\n    page: effectivePage,\n    totalPages,\n    hasNextPage,\n    hasPrevPage,\n    pagingCounter,\n    nextPage: hasNextPage ? effectivePage + 1 : null,\n    prevPage: hasPrevPage ? effectivePage - 1 : null,\n  } as Awaited<ReturnType<FindGlobalVersions>>;\n}\n","/**\n * @fileoverview Delete Operation Bindings\n *\n * This module implements Payload's delete operations for the Convex adapter.\n * It provides document deletion for:\n * - Single documents (by ID)\n * - Multiple documents (bulk delete via where clause)\n * - Version documents\n *\n * ## Collection Naming Conventions\n * - Regular collections: `{collection}`\n * - Version collections: `{collection}_versions`\n *\n * @module convex/bindings/delete\n */\n\nimport type { AdapterService } from \"../adapter/service\";\nimport { DeleteOne, DeleteMany, DeleteVersions } from \"payload\";\n\n/**\n * Props for the deleteOne operation.\n */\nexport type AdapterDeleteOneProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming deleteOne parameters from Payload */\n  incomingDeleteOne: Parameters<DeleteOne>[0];\n};\n\n/**\n * Props for the deleteMany operation.\n */\nexport type AdapterDeleteManyProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming deleteMany parameters from Payload */\n  incomingDeleteMany: Parameters<DeleteMany>[0];\n};\n\n/**\n * Props for the deleteVersions operation.\n */\nexport type AdapterDeleteVersionsProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming deleteVersions parameters from Payload */\n  incomingDeleteVersions: Parameters<DeleteVersions>[0];\n};\n\n/**\n * Deletes a single document from a collection matching a where clause.\n *\n * This function first fetches the document to return it, then deletes it.\n * This matches Payload's expected behavior of returning the deleted document.\n *\n * @param {AdapterDeleteOneProps} props - The deleteOne operation parameters\n * @returns {Promise<Awaited<ReturnType<DeleteOne>>>} The deleted document\n *\n * @example\n * ```typescript\n * const deletedDoc = await deleteOne({\n *   service,\n *   incomingDeleteOne: {\n *     collection: 'posts',\n *     where: { id: { equals: '123' } },\n *   },\n * });\n * ```\n */\nexport async function deleteOne(props: AdapterDeleteOneProps) {\n  const { service, incomingDeleteOne } = props;\n  const { returning = true } = incomingDeleteOne;\n\n  // Pass all incoming params to queryProcessor\n  const processedQuery = service.tools.queryProcessor({\n    service,\n    ...incomingDeleteOne,\n    convex: false,\n  });\n\n  // First, fetch the document to return it\n  const docs = await service.db.query({}).collectionWhereQuery.adapter({\n    service,\n    ...processedQuery.convexQueryProps,\n  });\n\n  if (!docs || docs.length === 0) {\n    return null as Awaited<ReturnType<DeleteOne>>;\n  }\n\n  const doc = docs[0];\n\n  // Delete the document\n  await service.db.mutation({}).deleteOp.adapter({\n    service,\n    id: doc._id as string,\n  });\n\n  // Only process result if returning is true (default)\n  if (!returning) {\n    return { id: doc._id } as Awaited<ReturnType<DeleteOne>>;\n  }\n\n  return processedQuery.processResult(doc) as Awaited<ReturnType<DeleteOne>>;\n}\n\n/**\n * Deletes multiple documents matching a where clause.\n *\n * This function uses the deleteManyWhere mutation to delete all documents\n * matching the provided filter criteria. Returns void per Payload's specification.\n *\n * @param {AdapterDeleteManyProps} props - The deleteMany operation parameters\n * @returns {Promise<Awaited<ReturnType<DeleteMany>>>} void\n *\n * @example\n * ```typescript\n * await deleteMany({\n *   service,\n *   incomingDeleteMany: {\n *     collection: 'posts',\n *     where: { status: { equals: 'draft' } },\n *   },\n * });\n * ```\n */\nexport async function deleteMany(props: AdapterDeleteManyProps) {\n  const { service, incomingDeleteMany } = props;\n\n  // Pass all incoming params to queryProcessor\n  const processedQuery = service.tools.queryProcessor({\n    service,\n    ...incomingDeleteMany,\n    convex: false,\n  });\n\n  // Delete all matching documents\n  await service.db.mutation({}).deleteManyWhere.adapter({\n    service,\n    ...processedQuery.convexQueryProps,\n  });\n}\n\n/**\n * Deletes version documents for a collection or global.\n *\n * Versions are stored in collections named `{collection}_versions` or `{global}_versions`.\n * This function deletes version documents matching the provided where clause.\n * Returns void per Payload's specification.\n *\n * @param {AdapterDeleteVersionsProps} props - The deleteVersions operation parameters\n * @returns {Promise<Awaited<ReturnType<DeleteVersions>>>} void\n *\n * @example\n * ```typescript\n * await deleteVersions({\n *   service,\n *   incomingDeleteVersions: {\n *     collection: 'posts',\n *     where: { parent: { equals: '123' } },\n *   },\n * });\n * ```\n */\nexport async function deleteVersions(props: AdapterDeleteVersionsProps) {\n  const { service, incomingDeleteVersions } = props;\n  const { collection, globalSlug, where, locale } = incomingDeleteVersions;\n\n  // Determine the versions collection name\n  const versionsCollection = collection\n    ? `${collection}_versions`\n    : `${globalSlug}_versions`;\n\n  // Pass compatible params to queryProcessor (sort is excluded as it has incompatible type)\n  const processedQuery = service.tools.queryProcessor({\n    service,\n    collection: versionsCollection,\n    where,\n    locale,\n    convex: false,\n  });\n\n  // Delete all matching version documents\n  await service.db.mutation({}).deleteManyWhere.adapter({\n    service,\n    ...processedQuery.convexQueryProps,\n  });\n}\n","/**\n * @fileoverview Update Operation Bindings\n *\n * This module implements Payload's update operations for the Convex adapter.\n * It provides document updates for:\n * - Single documents\n * - Multiple documents (bulk update)\n * - Global documents\n * - Document versions\n * - Global versions\n * - Job queue entries\n *\n * @module convex/bindings/update\n * @todo Implement all update operations\n */\n\nimport type { AdapterService } from \"../adapter/service\";\nimport {\n  UpdateOne,\n  UpdateMany,\n  UpdateGlobal,\n  UpdateVersion,\n  UpdateGlobalVersion,\n  UpdateJobs,\n} from \"payload\";\n\ntype IncrementOp = {\n  field: string;\n  amount: number;\n};\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === \"object\" && value !== null && !Array.isArray(value);\n}\n\nfunction splitIncrementOps(data: Record<string, unknown> | null | undefined) {\n  const incOps: IncrementOp[] = [];\n  const patchData: Record<string, unknown> = {};\n\n  if (!data) {\n    return { incOps, patchData };\n  }\n\n  for (const [field, value] of Object.entries(data)) {\n    if (isRecord(value) && \"$inc\" in value) {\n      const amount = (value as Record<string, unknown>)[\"$inc\"];\n      if (typeof amount !== \"number\") {\n        throw new Error(\n          `Unsupported $inc payload for field '${field}': expected number`\n        );\n      }\n      incOps.push({ field, amount });\n      continue;\n    }\n\n    patchData[field] = value;\n  }\n\n  return { incOps, patchData };\n}\n\nasync function applyPatchWithIncrements(\n  service: AdapterService,\n  id: string,\n  data: Record<string, unknown> | null | undefined\n) {\n  const { incOps, patchData } = splitIncrementOps(data);\n\n  if (Object.keys(patchData).length > 0) {\n    await service.db.mutation({}).patch.adapter({\n      service,\n      id,\n      data: patchData,\n    });\n  }\n\n  for (const inc of incOps) {\n    await service.db.mutation({}).increment.adapter({\n      service,\n      id,\n      field: inc.field,\n      amount: inc.amount,\n    });\n  }\n}\n\n/**\n * Props for the updateOne operation.\n */\nexport type AdapterUpdateOneProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming updateOne parameters from Payload */\n  incomingUpdateOne: Parameters<UpdateOne>[0];\n};\n\n/**\n * Props for the updateMany operation.\n */\nexport type AdapterUpdateManyProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming updateMany parameters from Payload */\n  incomingUpdateMany: Parameters<UpdateMany>[0];\n};\n\n/**\n * Props for the updateGlobal operation.\n */\nexport type AdapterUpdateGlobalProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming updateGlobal parameters from Payload */\n  incomingUpdateGlobal: Parameters<UpdateGlobal>[0];\n};\n\n/**\n * Props for the updateVersion operation.\n */\nexport type AdapterUpdateVersionProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming updateVersion parameters from Payload */\n  incomingUpdateVersion: Parameters<UpdateVersion>[0];\n};\n\n/**\n * Props for the updateGlobalVersion operation.\n */\nexport type AdapterUpdateGlobalVersionProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming updateGlobalVersion parameters from Payload */\n  incomingUpdateGlobalVersion: Parameters<UpdateGlobalVersion>[0];\n};\n\n/**\n * Props for the updateJobs operation.\n */\nexport type AdapterUpdateJobsProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming updateJobs parameters from Payload */\n  incomingUpdateJobs: Parameters<UpdateJobs>[0];\n};\n\n/**\n * Updates a single document in a collection.\n *\n * UpdateOne can use either an `id` or a `where` clause to identify the document.\n *\n * @param {AdapterUpdateOneProps} props - The updateOne operation parameters\n * @returns {Promise<Awaited<ReturnType<UpdateOne>>>} The updated document\n *\n * @example\n * ```typescript\n * const updatedDoc = await updateOne({\n *   service,\n *   incomingUpdateOne: {\n *     collection: 'posts',\n *     where: { id: { equals: '123' } },\n *     data: { title: 'Updated Title' },\n *   },\n * });\n * ```\n */\nexport async function updateOne(props: AdapterUpdateOneProps) {\n  const { service, incomingUpdateOne } = props;\n  const {\n    collection,\n    data,\n    id,\n    where,\n    draft,\n    returning = true,\n  } = incomingUpdateOne;\n\n  let docId: string;\n\n  // If ID is provided directly, use it\n  if (id) {\n    docId = id as string;\n  } else if (where) {\n    // Otherwise, find the document using the where clause\n    const processedQuery = service.tools.queryProcessor({\n      service,\n      ...incomingUpdateOne,\n      limit: 1,\n      convex: false,\n    });\n\n    const docs = await service.db.query({}).collectionWhereLimitQuery.adapter({\n      service,\n      ...processedQuery.convexQueryProps,\n      limit: processedQuery.convexQueryProps.limit!,\n    });\n\n    if (!docs || docs.length === 0) {\n      throw new Error(\n        `updateOne: Document not found in collection '${collection}' matching where clause`\n      );\n    }\n\n    docId = docs[0]._id as string;\n  } else {\n    throw new Error(\"updateOne requires either id or where parameter\");\n  }\n\n  // Prepare update data with draft status if applicable\n  const updateData =\n    draft !== undefined\n      ? { ...data, _status: draft ? \"draft\" : \"published\" }\n      : data;\n\n  // Update the document using patch\n  await applyPatchWithIncrements(\n    service,\n    docId,\n    updateData as Record<string, unknown>\n  );\n\n  // Only fetch if returning is true (default)\n  if (!returning) {\n    return { id: docId } as Awaited<ReturnType<UpdateOne>>;\n  }\n\n  // Fetch and return the updated document\n  const updatedDoc = await service.db.query({}).getById.adapter({\n    service,\n    collection,\n    id: docId,\n  });\n\n  if (!updatedDoc) {\n    throw new Error(\n      `updateOne: Document with id '${docId}' not found after update in collection '${collection}'`\n    );\n  }\n\n  // Process result through queryProcessor for format conversion\n  const processedQuery = service.tools.queryProcessor({\n    service,\n    ...incomingUpdateOne,\n    convex: false,\n  });\n\n  return processedQuery.processResult(updatedDoc) as Awaited<\n    ReturnType<UpdateOne>\n  >;\n}\n\n/**\n * Updates multiple documents matching a where clause.\n *\n * @param {AdapterUpdateManyProps} props - The updateMany operation parameters\n * @returns {Promise<Awaited<ReturnType<UpdateMany>>>} Array of updated documents or null\n *\n * @example\n * ```typescript\n * const updatedDocs = await updateMany({\n *   service,\n *   incomingUpdateMany: {\n *     collection: 'posts',\n *     where: { status: { equals: 'draft' } },\n *     data: { status: 'published' },\n *   },\n * });\n * ```\n */\nexport async function updateMany(props: AdapterUpdateManyProps) {\n  const { service, incomingUpdateMany } = props;\n  const {\n    collection,\n    data,\n    draft,\n    limit,\n    returning = true,\n  } = incomingUpdateMany;\n\n  // Pass all incoming params to queryProcessor\n  const processedQuery = service.tools.queryProcessor({\n    service,\n    ...incomingUpdateMany,\n    convex: false,\n  });\n\n  // First, fetch all matching documents to get their IDs\n  const docs = await service.db.query({}).collectionWhereQuery.adapter({\n    service,\n    ...processedQuery.convexQueryProps,\n  });\n\n  if (!docs || docs.length === 0) {\n    return null as Awaited<ReturnType<UpdateMany>>;\n  }\n\n  // Apply limit if provided\n  const docsToUpdate = limit ? docs.slice(0, limit) : docs;\n\n  // Prepare update data with draft status if applicable\n  const updateData =\n    draft !== undefined\n      ? { ...data, _status: draft ? \"draft\" : \"published\" }\n      : data;\n\n  // Update each document\n  for (const doc of docsToUpdate) {\n    await applyPatchWithIncrements(\n      service,\n      doc._id as string,\n      updateData as Record<string, unknown>\n    );\n  }\n\n  // Only fetch if returning is true (default)\n  if (!returning) {\n    return null as Awaited<ReturnType<UpdateMany>>;\n  }\n\n  // Fetch and return all updated documents\n  const updatedDocs = await service.db.query({}).collectionWhereQuery.adapter({\n    service,\n    ...processedQuery.convexQueryProps,\n  });\n\n  // Apply limit to returned docs if provided\n  const rawDocs = limit ? updatedDocs.slice(0, limit) : updatedDocs;\n\n  return processedQuery.processResult(rawDocs) as Awaited<\n    ReturnType<UpdateMany>\n  >;\n}\n\n/**\n * Updates a global document.\n *\n * Globals are singleton documents stored in collections named `_globals_{slug}`.\n *\n * @param {AdapterUpdateGlobalProps} props - The updateGlobal operation parameters\n * @returns {Promise<Awaited<ReturnType<UpdateGlobal>>>} The updated global document\n *\n * @example\n * ```typescript\n * const updatedGlobal = await updateGlobal({\n *   service,\n *   incomingUpdateGlobal: {\n *     slug: 'settings',\n *     data: { siteName: 'Updated Site Name' },\n *   },\n * });\n * ```\n */\nexport async function updateGlobal(props: AdapterUpdateGlobalProps) {\n  const { service, incomingUpdateGlobal } = props;\n  const { slug, data, returning = true } = incomingUpdateGlobal;\n\n  // Globals are stored in a collection named after the slug\n  const globalCollection = `_globals_${slug}`;\n\n  // Find the global document (should be only one)\n  const docs = await service.db.query({}).collectionWhereLimitQuery.adapter({\n    service,\n    collection: globalCollection,\n    wherePlan: service.tools.emptyWherePlan(),\n    limit: 1,\n    index: undefined,\n  });\n\n  if (!docs || docs.length === 0) {\n    // If no global exists, this should not happen in normal operation\n    // The global should be created first with createGlobal\n    throw new Error(`Global document not found for slug: ${slug}`);\n  }\n\n  const docId = docs[0]._id as string;\n\n  // Update the global document\n  await applyPatchWithIncrements(\n    service,\n    docId,\n    data as Record<string, unknown>\n  );\n\n  // Only fetch if returning is true (default)\n  if (!returning) {\n    return { id: docId } as unknown as Awaited<ReturnType<UpdateGlobal>>;\n  }\n\n  // Fetch and return the updated global\n  const updatedDoc = await service.db.query({}).getById.adapter({\n    service,\n    collection: globalCollection,\n    id: docId,\n  });\n\n  // Process result through queryProcessor for format conversion\n  const processedQuery = service.tools.queryProcessor({\n    service,\n    ...incomingUpdateGlobal,\n    collection: globalCollection,\n    convex: false,\n  });\n\n  return processedQuery.processResult(updatedDoc) as unknown as Awaited<\n    ReturnType<UpdateGlobal>\n  >;\n}\n\n/**\n * Updates a document version.\n *\n * Versions are stored in collections named `{collection}_versions`.\n * Can update by either `id` or `where` clause.\n *\n * @param {AdapterUpdateVersionProps} props - The updateVersion operation parameters\n * @returns {Promise<Awaited<ReturnType<UpdateVersion>>>} The updated version document\n *\n * @example\n * ```typescript\n * const updatedVersion = await updateVersion({\n *   service,\n *   incomingUpdateVersion: {\n *     collection: 'posts',\n *     id: 'version123',\n *     versionData: { latest: true },\n *   },\n * });\n * ```\n */\nexport async function updateVersion(props: AdapterUpdateVersionProps) {\n  const { service, incomingUpdateVersion } = props;\n  const {\n    collection,\n    versionData,\n    id,\n    where,\n    returning = true,\n  } = incomingUpdateVersion;\n\n  // Versions are stored in a collection with \"_versions\" suffix\n  const versionsCollection = `${collection}_versions`;\n\n  let docId: string;\n\n  // If ID is provided directly, use it\n  if (id) {\n    docId = id as string;\n  } else if (where) {\n    // Otherwise, find the version using the where clause\n    const processedQuery = service.tools.queryProcessor({\n      service,\n      ...incomingUpdateVersion,\n      collection: versionsCollection,\n      limit: 1,\n      convex: false,\n    });\n\n    const docs = await service.db.query({}).collectionWhereLimitQuery.adapter({\n      service,\n      ...processedQuery.convexQueryProps,\n      limit: 1,\n    });\n\n    if (!docs || docs.length === 0) {\n      return null as unknown as Awaited<ReturnType<UpdateVersion>>;\n    }\n\n    docId = docs[0]._id as string;\n  } else {\n    throw new Error(\"updateVersion requires either id or where parameter\");\n  }\n\n  // Update the version document\n  await applyPatchWithIncrements(\n    service,\n    docId,\n    versionData as Record<string, unknown>\n  );\n\n  // Only fetch if returning is true (default)\n  if (!returning) {\n    return { id: docId } as Awaited<ReturnType<UpdateVersion>>;\n  }\n\n  // Fetch and return the updated version\n  const updatedDoc = await service.db.query({}).getById.adapter({\n    service,\n    collection: versionsCollection,\n    id: docId,\n  });\n\n  // Process result through queryProcessor for format conversion\n  const processedQuery = service.tools.queryProcessor({\n    service,\n    ...incomingUpdateVersion,\n    collection: versionsCollection,\n    convex: false,\n  });\n\n  return processedQuery.processResult(updatedDoc) as Awaited<\n    ReturnType<UpdateVersion>\n  >;\n}\n\n/**\n * Updates a global version document.\n *\n * Global versions are stored in collections named `{global}_global_versions`.\n * Can update by either `id` or `where` clause.\n *\n * @param {AdapterUpdateGlobalVersionProps} props - The updateGlobalVersion operation parameters\n * @returns {Promise<Awaited<ReturnType<UpdateGlobalVersion>>>} The updated global version document\n *\n * @example\n * ```typescript\n * const updatedGlobalVersion = await updateGlobalVersion({\n *   service,\n *   incomingUpdateGlobalVersion: {\n *     global: 'settings',\n *     id: 'version123',\n *     versionData: { latest: true },\n *   },\n * });\n * ```\n */\nexport async function updateGlobalVersion(\n  props: AdapterUpdateGlobalVersionProps\n) {\n  const { service, incomingUpdateGlobalVersion } = props;\n  const {\n    global,\n    versionData,\n    id,\n    where,\n    returning = true,\n  } = incomingUpdateGlobalVersion;\n\n  // Global versions are stored in a collection with \"_global_versions\" suffix\n  const globalVersionsCollection = `${global}_global_versions`;\n\n  let docId: string;\n\n  // If ID is provided directly, use it\n  if (id) {\n    docId = id as string;\n  } else if (where) {\n    // Otherwise, find the version using the where clause\n    const processedQuery = service.tools.queryProcessor({\n      service,\n      ...incomingUpdateGlobalVersion,\n      collection: globalVersionsCollection,\n      limit: 1,\n      convex: false,\n    });\n\n    const docs = await service.db.query({}).collectionWhereLimitQuery.adapter({\n      service,\n      ...processedQuery.convexQueryProps,\n      limit: 1,\n    });\n\n    if (!docs || docs.length === 0) {\n      return null as unknown as Awaited<ReturnType<UpdateGlobalVersion>>;\n    }\n\n    docId = docs[0]._id as string;\n  } else {\n    throw new Error(\n      \"updateGlobalVersion requires either id or where parameter\"\n    );\n  }\n\n  // Update the global version document\n  await applyPatchWithIncrements(\n    service,\n    docId,\n    versionData as Record<string, unknown>\n  );\n\n  // Only fetch if returning is true (default)\n  if (!returning) {\n    return { id: docId } as Awaited<ReturnType<UpdateGlobalVersion>>;\n  }\n\n  // Fetch and return the updated global version\n  const updatedDoc = await service.db.query({}).getById.adapter({\n    service,\n    collection: globalVersionsCollection,\n    id: docId,\n  });\n\n  // Process result through queryProcessor for format conversion\n  const processedQuery = service.tools.queryProcessor({\n    service,\n    ...incomingUpdateGlobalVersion,\n    collection: globalVersionsCollection,\n    convex: false,\n  });\n\n  return processedQuery.processResult(updatedDoc) as Awaited<\n    ReturnType<UpdateGlobalVersion>\n  >;\n}\n\n/**\n * Updates job queue entries.\n *\n * Jobs are stored in a special `_jobs` collection.\n * Can update by either `id` or `where` clause with optional `limit`.\n *\n * @param {AdapterUpdateJobsProps} props - The updateJobs operation parameters\n * @returns {Promise<Awaited<ReturnType<UpdateJobs>>>} Array of updated job entries or null\n *\n * @example\n * ```typescript\n * const updatedJobs = await updateJobs({\n *   service,\n *   incomingUpdateJobs: {\n *     where: { status: { equals: 'pending' } },\n *     data: { status: 'processing' },\n *     limit: 10,\n *   },\n * });\n * ```\n */\nexport async function updateJobs(props: AdapterUpdateJobsProps) {\n  const { service, incomingUpdateJobs } = props;\n  const { data, id, where, limit, returning = true } = incomingUpdateJobs;\n\n  const jobsCollection = \"_jobs\";\n\n  // If ID is provided, update a single job\n  if (id) {\n    await applyPatchWithIncrements(\n      service,\n      id as string,\n      data as Record<string, unknown>\n    );\n\n    // Only fetch if returning is true (default)\n    if (!returning) {\n      return [{ id }] as Awaited<ReturnType<UpdateJobs>>;\n    }\n\n    // Fetch and return the updated job\n    const updatedJob = await service.db.query({}).getById.adapter({\n      service,\n      collection: jobsCollection,\n      id: id as string,\n    });\n\n    // Process result through queryProcessor for format conversion\n    const processedQuery = service.tools.queryProcessor({\n      service,\n      ...incomingUpdateJobs,\n      collection: jobsCollection,\n      convex: false,\n    });\n\n    return [processedQuery.processResult(updatedJob)] as Awaited<\n      ReturnType<UpdateJobs>\n    >;\n  }\n\n  // Otherwise, update jobs matching the where clause\n  if (where) {\n    // Pass all incoming params to queryProcessor\n    const processedQuery = service.tools.queryProcessor({\n      service,\n      ...incomingUpdateJobs,\n      collection: jobsCollection,\n      convex: false,\n    });\n\n    // Fetch matching jobs\n    const jobs = limit\n      ? await service.db.query({}).collectionWhereLimitQuery.adapter({\n          service,\n          ...processedQuery.convexQueryProps,\n          limit: processedQuery.convexQueryProps.limit!,\n        })\n      : await service.db.query({}).collectionWhereQuery.adapter({\n          service,\n          ...processedQuery.convexQueryProps,\n        });\n\n    if (!jobs || jobs.length === 0) {\n      return null as Awaited<ReturnType<UpdateJobs>>;\n    }\n\n    // Update each job\n    for (const job of jobs) {\n      await applyPatchWithIncrements(\n        service,\n        job._id as string,\n        data as Record<string, unknown>\n      );\n    }\n\n    // Only fetch if returning is true (default)\n    if (!returning) {\n      return null as Awaited<ReturnType<UpdateJobs>>;\n    }\n\n    // Fetch and return all updated jobs\n    const updatedJobs = limit\n      ? await service.db.query({}).collectionWhereLimitQuery.adapter({\n          service,\n          ...processedQuery.convexQueryProps,\n          limit: processedQuery.convexQueryProps.limit!,\n        })\n      : await service.db.query({}).collectionWhereQuery.adapter({\n          service,\n          ...processedQuery.convexQueryProps,\n        });\n\n    return processedQuery.processResult(updatedJobs) as Awaited<\n      ReturnType<UpdateJobs>\n    >;\n  }\n\n  throw new Error(\"updateJobs requires either id or where parameter\");\n}\n","/**\n * @fileoverview Upsert Operation Bindings\n *\n * This module implements Payload's upsert operation for the Convex adapter.\n * Upsert creates a document if it doesn't exist, or updates it if it does.\n *\n * @module convex/bindings/upsert\n */\n\nimport type { AdapterService } from \"../adapter/service\";\nimport { Upsert } from \"payload\";\n\ntype IncrementOp = {\n  field: string;\n  amount: number;\n};\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === \"object\" && value !== null && !Array.isArray(value);\n}\n\nfunction splitIncrementOps(data: Record<string, unknown> | null | undefined) {\n  const incOps: IncrementOp[] = [];\n  const patchData: Record<string, unknown> = {};\n\n  if (!data) {\n    return { incOps, patchData };\n  }\n\n  for (const [field, value] of Object.entries(data)) {\n    if (isRecord(value) && \"$inc\" in value) {\n      const amount = (value as Record<string, unknown>)[\"$inc\"];\n      if (typeof amount !== \"number\") {\n        throw new Error(\n          `Unsupported $inc payload for field '${field}': expected number`\n        );\n      }\n      incOps.push({ field, amount });\n      continue;\n    }\n\n    patchData[field] = value;\n  }\n\n  return { incOps, patchData };\n}\n\nasync function applyPatchWithIncrements(\n  service: AdapterService,\n  id: string,\n  data: Record<string, unknown> | null | undefined\n) {\n  const { incOps, patchData } = splitIncrementOps(data);\n\n  if (Object.keys(patchData).length > 0) {\n    await service.db.mutation({}).patch.adapter({\n      service,\n      id,\n      data: patchData,\n    });\n  }\n\n  for (const inc of incOps) {\n    await service.db.mutation({}).increment.adapter({\n      service,\n      id,\n      field: inc.field,\n      amount: inc.amount,\n    });\n  }\n}\n\nfunction normalizeInsertData(data: Record<string, unknown> | null | undefined) {\n  const { incOps, patchData } = splitIncrementOps(data);\n  if (incOps.length === 0) {\n    return patchData;\n  }\n\n  const normalized = { ...patchData };\n  for (const inc of incOps) {\n    normalized[inc.field] = inc.amount;\n  }\n\n  return normalized;\n}\n\n/**\n * Props for the upsert operation.\n */\nexport type AdapterUpsertProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming upsert parameters from Payload */\n  incomingUpsert: Parameters<Upsert>[0];\n};\n\n/**\n * Inserts or updates a document based on matching criteria.\n *\n * This function searches for a document matching the where clause.\n * If found, it updates the document. If not found, it creates a new one.\n *\n * @param {AdapterUpsertProps} props - The upsert operation parameters\n * @returns {Promise<Awaited<ReturnType<Upsert>>>} The upserted document\n *\n * @example\n * ```typescript\n * const doc = await upsert({\n *   service,\n *   incomingUpsert: {\n *     collection: 'posts',\n *     where: { slug: { equals: 'hello-world' } },\n *     data: { title: 'Hello World', content: 'Updated content' },\n *   },\n * });\n * ```\n */\nexport async function upsert(props: AdapterUpsertProps) {\n  const { service, incomingUpsert } = props;\n  const { collection, data, returning = true } = incomingUpsert;\n\n  // Pass all incoming params to queryProcessor\n  const processedQuery = service.tools.queryProcessor({\n    service,\n    ...incomingUpsert,\n    limit: 1,\n    convex: false,\n  });\n\n  // Try to find an existing document\n  const existingDocs = await service.db\n    .query({})\n    .collectionWhereLimitQuery.adapter({\n      service,\n      ...processedQuery.convexQueryProps,\n      limit: processedQuery.convexQueryProps.limit!,\n    });\n\n  if (existingDocs && existingDocs.length > 0) {\n    // Document exists - update it\n    const docId = existingDocs[0]._id as string;\n\n    await applyPatchWithIncrements(\n      service,\n      docId,\n      data as Record<string, unknown>\n    );\n\n    // Only fetch if returning is true (default)\n    if (!returning) {\n      return { id: docId } as Awaited<ReturnType<Upsert>>;\n    }\n\n    // Fetch and return the updated document\n    const updatedDoc = await service.db.query({}).getById.adapter({\n      service,\n      collection,\n      id: docId,\n    });\n\n    return processedQuery.processResult(updatedDoc) as Awaited<\n      ReturnType<Upsert>\n    >;\n  } else {\n    // Document doesn't exist - create it\n    const normalizedData = normalizeInsertData(data as Record<string, unknown>);\n\n    const docId = await service.db.mutation({}).insert.adapter({\n      service,\n      collection,\n      data: normalizedData,\n    });\n\n    // Only fetch if returning is true (default)\n    if (!returning) {\n      return { id: docId } as Awaited<ReturnType<Upsert>>;\n    }\n\n    // Fetch and return the created document\n    const newDoc = await service.db.query({}).getById.adapter({\n      service,\n      collection,\n      id: docId as string,\n    });\n\n    return processedQuery.processResult(newDoc) as Awaited<ReturnType<Upsert>>;\n  }\n}\n","/**\n * @fileoverview Query Drafts Operation Bindings\n *\n * This module implements Payload's queryDrafts operation for the Convex adapter.\n * Draft documents are unpublished versions of documents that can be queried\n * separately from published content.\n *\n * Drafts are identified by a `_status` field set to 'draft'.\n *\n * @module convex/bindings/queryDrafts\n */\n\nimport type { AdapterService } from \"../adapter/service\";\nimport { QueryDrafts, type Where } from \"payload\";\n\n/**\n * Props for the queryDrafts operation.\n */\nexport type AdapterQueryDraftsProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming queryDrafts parameters from Payload */\n  incomingQueryDrafts: Parameters<QueryDrafts>[0];\n};\n\n/**\n * Queries draft documents from a collection.\n *\n * Draft documents have a `_status` field set to 'draft'.\n * This function returns paginated results of draft documents with\n * support for filtering, sorting, and pagination.\n *\n * @param {AdapterQueryDraftsProps} props - The queryDrafts operation parameters\n * @returns {Promise<Awaited<ReturnType<QueryDrafts>>>} Paginated draft documents result\n *\n * @example\n * ```typescript\n * const drafts = await queryDrafts({\n *   service,\n *   incomingQueryDrafts: {\n *     collection: 'posts',\n *     where: { author: { equals: 'user123' } },\n *     limit: 10,\n *     page: 1,\n *   },\n * });\n * ```\n */\nexport async function queryDrafts(props: AdapterQueryDraftsProps) {\n  const { service, incomingQueryDrafts } = props;\n  const {\n    where,\n    limit = 10,\n    page = 1,\n    pagination = true,\n  } = incomingQueryDrafts;\n\n  // Combine the where clause with draft status filter\n  const draftWhere: Where = where\n    ? {\n        and: [where, { _status: { equals: \"draft\" } }],\n      }\n    : { _status: { equals: \"draft\" } };\n\n  // Pass all incoming params to queryProcessor with draft where clause\n  const processedQuery = service.tools.queryProcessor({\n    service,\n    ...incomingQueryDrafts,\n    where: draftWhere,\n    convex: false,\n  });\n\n  // If pagination is disabled (limit = 0), fetch all draft documents\n  if (!pagination || limit === 0) {\n    const rawDocs = await service.db.query({}).collectionWhereQuery.adapter({\n      service,\n      ...processedQuery.convexQueryProps,\n    });\n\n    const docs = processedQuery.processResult(rawDocs);\n\n    return {\n      docs,\n      totalDocs: docs.length,\n      limit: docs.length,\n      page: 1,\n      totalPages: 1,\n      hasNextPage: false,\n      hasPrevPage: false,\n      pagingCounter: 1,\n    } as Awaited<ReturnType<QueryDrafts>>;\n  }\n\n  // Get total count for pagination calculations\n  const totalDocs = await service.db.query({}).collectionCountQuery.adapter({\n    service,\n    ...processedQuery.convexQueryProps,\n  });\n\n  const totalPages = Math.ceil(totalDocs / limit);\n  const hasNextPage = page < totalPages;\n  const hasPrevPage = page > 1;\n  const pagingCounter = (page - 1) * limit + 1;\n\n  // Fetch documents with ordering and pagination\n  const skip = (page - 1) * limit;\n\n  const allDocs = await service.db.query({}).collectionWhereOrderQuery.adapter({\n    service,\n    ...processedQuery.convexQueryProps,\n    order: processedQuery.convexQueryProps.order ?? \"desc\",\n  });\n\n  const rawDocs = allDocs.slice(skip, skip + limit);\n  const docs = processedQuery.processResult(rawDocs);\n\n  return {\n    docs,\n    totalDocs,\n    limit,\n    page,\n    totalPages,\n    hasNextPage,\n    hasPrevPage,\n    pagingCounter,\n    nextPage: hasNextPage ? page + 1 : null,\n    prevPage: hasPrevPage ? page - 1 : null,\n  } as Awaited<ReturnType<QueryDrafts>>;\n}\n","/**\n * @fileoverview Migration Operation Bindings\n *\n * This module implements Payload's migration operations for the Convex adapter.\n * Migrations handle database schema changes and data transformations.\n *\n * ## Migration Operations\n * - **migrate**: Run pending migrations\n * - **migrateDown**: Rollback the last migration\n * - **migrateFresh**: Drop all data and re-run all migrations\n * - **migrateRefresh**: Rollback all migrations and re-run them\n * - **migrateReset**: Rollback all migrations\n * - **migrateStatus**: Show the status of all migrations\n *\n * @module convex/bindings/migrate\n * @todo Implement all migration operations\n */\n\nimport type { AdapterService } from \"../adapter/service\";\n\nimport { Migration } from \"payload\";\n\n/**\n * Props for the migrate operation.\n */\nexport type AdapterMigrateProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n  /** The incoming migrate parameters from Payload */\n  incomingMigrate:\n    | {\n        migrations?: Migration[];\n      }\n    | undefined;\n};\n\n/**\n * Props for the migrateDown operation.\n */\nexport type AdapterMigrateDownProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n};\n\n/**\n * Props for the migrateFresh operation.\n */\nexport type AdapterMigrateFreshProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n};\n\n/**\n * Props for the migrateRefresh operation.\n */\nexport type AdapterMigrateRefreshProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n};\n\n/**\n * Props for the migrateReset operation.\n */\nexport type AdapterMigrateResetProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n};\n\n/**\n * Props for the migrateStatus operation.\n */\nexport type AdapterMigrateStatusProps = {\n  /** The adapter service instance */\n  service: AdapterService;\n};\n\n/**\n * Runs pending database migrations.\n *\n * @param {AdapterMigrateProps} props - The migrate operation parameters\n * @returns {Promise<void>} Currently not implemented\n * @todo Implement migration execution\n */\nexport async function migrate(props: AdapterMigrateProps) {\n  // Not implemented\n}\n\n/**\n * Rolls back the last migration.\n *\n * @param {Object} props - The migrateDown operation parameters\n * @returns {Promise<void>} Currently not implemented\n * @todo Implement migration rollback\n */\nexport async function migrateDown(props: {}) {\n  // Not implemented\n}\n\n/**\n * Drops all data and re-runs all migrations from scratch.\n *\n * @param {Object} props - The migrateFresh operation parameters\n * @returns {Promise<void>} Currently not implemented\n * @todo Implement fresh migration\n */\nexport async function migrateFresh(props: {}) {\n  // Not implemented\n}\n\n/**\n * Rolls back all migrations and re-runs them.\n *\n * @param {Object} props - The migrateRefresh operation parameters\n * @returns {Promise<void>} Currently not implemented\n * @todo Implement migration refresh\n */\nexport async function migrateRefresh(props: {}) {\n  // Not implemented\n}\n\n/**\n * Rolls back all migrations.\n *\n * @param {Object} props - The migrateReset operation parameters\n * @returns {Promise<void>} Currently not implemented\n * @todo Implement migration reset\n */\nexport async function migrateReset(props: {}) {\n  // Not implemented\n}\n\n/**\n * Shows the status of all migrations.\n *\n * @param {Object} props - The migrateStatus operation parameters\n * @returns {Promise<void>} Currently not implemented\n * @todo Implement migration status reporting\n */\nexport async function migrateStatus(props: {}) {\n  // Not implemented\n}\n"]}